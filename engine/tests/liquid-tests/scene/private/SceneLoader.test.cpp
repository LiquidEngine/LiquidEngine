#include "liquid/core/Base.h"
#include "liquid-tests/Testing.h"

#include "liquid/entity/EntityDatabase.h"
#include "liquid/scene/private/SceneLoader.h"

class SceneLoaderTest : public ::testing::Test {
public:
  SceneLoaderTest() : sceneLoader(assetRegistry, entityDatabase) {}

  std::pair<YAML::Node, liquid::Entity> createNode(bool create = true) {
    auto id = lastId++;

    YAML::Node node;
    node["id"] = id;
    node["version"] = "0.1";
    node["components"] = YAML::Node(YAML::NodeType::Map);

    if (create) {
      auto entity = entityDatabase.create();
      entityIdCache.insert_or_assign(id, entity);

      entityDatabase.set<liquid::IdComponent>(entity, {id});

      return {node, entity};
    }

    return {node, liquid::EntityNull};
  }

public:
  liquid::AssetRegistry assetRegistry;
  liquid::EntityDatabase entityDatabase;
  liquid::detail::EntityIdCache entityIdCache;
  liquid::detail::SceneLoader sceneLoader;

private:
  uint32_t lastId = 1;
};

using SceneLoaderNameTest = SceneLoaderTest;

TEST_F(SceneLoaderNameTest, CreatesAutoGeneratedNameIfNameFieldIsNotDefined) {
  auto [node, entity] = createNode();
  auto untitledName = "Untitled " + node["id"].as<liquid::String>();

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::NameComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::NameComponent>(entity).name,
            untitledName);
}

TEST_F(SceneLoaderNameTest, CreatesAutoGeneratedNameIfNameFieldIsInvalid) {
  auto [node, entity] = createNode();
  auto untitledName = "Untitled " + node["id"].as<liquid::String>();

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::NameComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::NameComponent>(entity).name,
            untitledName);
}

TEST_F(SceneLoaderNameTest, CreatesNameComponentWithFileDataIfValidField) {
  auto [node, entity] = createNode();
  node["components"]["name"] = "Hello World";

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::NameComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::NameComponent>(entity).name,
            "Hello World");
}

using SceneLoaderTransformTest = SceneLoaderTest;

TEST_F(SceneLoaderTransformTest, CreatesIdentityWorldTransform) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::WorldTransformComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::WorldTransformComponent>(entity)
                .worldTransform,
            glm::mat4{1.0f});
}

TEST_F(SceneLoaderTransformTest,
       CreatesEmptyTransformComponentIfTransformFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  liquid::LocalTransformComponent expected{};

  EXPECT_TRUE(entityDatabase.has<liquid::LocalTransformComponent>(entity));

  const auto &actual =
      entityDatabase.get<liquid::LocalTransformComponent>(entity);

  EXPECT_EQ(actual.localPosition, expected.localPosition);
  EXPECT_EQ(actual.localRotation, expected.localRotation);
  EXPECT_EQ(actual.localScale, expected.localScale);

  EXPECT_EQ(entityDatabase.get<liquid::WorldTransformComponent>(entity)
                .worldTransform,
            glm::mat4{1.0f});
}

TEST_F(SceneLoaderTransformTest,
       TriesToFillAllPossibleValuesIfInvalidStructure) {

  liquid::LocalTransformComponent defaults{};
  glm::vec3 validPosition(2.0f);
  glm::quat validRotation(0.0f, 1.0f, 0.0f, 0.0f);
  glm::vec3 validScale(4.5f);

  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["transform"]["position"] = value;
    node["components"]["transform"]["rotation"] = validRotation;
    node["components"]["transform"]["scale"] = validScale;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    const auto &transform =
        entityDatabase.get<liquid::LocalTransformComponent>(entity);

    EXPECT_EQ(transform.localPosition, defaults.localPosition);
    EXPECT_EQ(transform.localRotation, validRotation);
    EXPECT_EQ(transform.localScale, validScale);
  }

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["transform"]["position"] = validPosition;
    node["components"]["transform"]["rotation"] = value;
    node["components"]["transform"]["scale"] = validScale;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    const auto &transform =
        entityDatabase.get<liquid::LocalTransformComponent>(entity);

    EXPECT_EQ(transform.localPosition, validPosition);
    EXPECT_EQ(transform.localRotation, defaults.localRotation);
    EXPECT_EQ(transform.localScale, validScale);
  }

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["transform"]["position"] = validPosition;
    node["components"]["transform"]["rotation"] = validRotation;
    node["components"]["transform"]["scale"] = value;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    const auto &transform =
        entityDatabase.get<liquid::LocalTransformComponent>(entity);

    EXPECT_EQ(transform.localPosition, validPosition);
    EXPECT_EQ(transform.localRotation, validRotation);
    EXPECT_EQ(transform.localScale, defaults.localScale);
  }
}

TEST_F(SceneLoaderTransformTest,
       CreatesTransformComponentWithFileDataIfValidField) {
  liquid::LocalTransformComponent defaults{};
  glm::vec3 validPosition(2.0f);
  glm::quat validRotation(0.0f, 1.0f, 0.0f, 0.0f);
  glm::vec3 validScale(4.5f);

  auto [node, entity] = createNode();
  node["components"]["transform"]["position"] = validPosition;
  node["components"]["transform"]["rotation"] = validRotation;
  node["components"]["transform"]["scale"] = validScale;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  const auto &transform =
      entityDatabase.get<liquid::LocalTransformComponent>(entity);
  EXPECT_EQ(transform.localPosition, validPosition);
  EXPECT_EQ(transform.localRotation, validRotation);
  EXPECT_EQ(transform.localScale, validScale);
}

using SceneLoaderMeshTest = SceneLoaderTest;

TEST_F(SceneLoaderMeshTest, DoesNotCreateMeshComponentIfMeshFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::MeshComponent>(entity));
}

TEST_F(SceneLoaderMeshTest, DoesNotCreateMeshComponentIfMeshFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["mesh"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::MeshComponent>(entity));
  }
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateMeshComponentIfNoMeshHandleInRegistry) {
  liquid::AssetData<liquid::MeshAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["mesh"] = "hello.lqmesh";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::MeshComponent>(entity));
}

TEST_F(SceneLoaderMeshTest, CreatesMeshComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::MeshAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["mesh"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::MeshComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::MeshComponent>(entity).handle, handle);
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateSkinnedMeshComponentIfMeshFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::SkinnedMeshComponent>(entity));
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateSkinnedMeshComponentIfMeshFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skinnedMesh"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::SkinnedMeshComponent>(entity));
  }
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateSkinnedMeshComponentIfNoSkinnedMeshHandleInRegistry) {
  liquid::AssetData<liquid::SkinnedMeshAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getSkinnedMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["skinnedMesh"] = "hello.lqmesh";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::SkinnedMeshComponent>(entity));
}

TEST_F(SceneLoaderMeshTest,
       CreatesSkinnedMeshComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::SkinnedMeshAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getSkinnedMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["skinnedMesh"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::SkinnedMeshComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::SkinnedMeshComponent>(entity).handle,
            handle);
}

using SceneLoaderSkeletonTest = SceneLoaderTest;

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfSkeletonFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::SkeletonComponent>(entity));
}

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfSkeletonFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skeleton"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::SkeletonComponent>(entity));
  }
}

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfNoSkeletonHandleInRegistry) {
  liquid::AssetData<liquid::SkeletonAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqskel";
  auto handle = assetRegistry.getSkeletons().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["skeleton"] = "hello.lqskel";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::SkeletonComponent>(entity));
}

TEST_F(SceneLoaderSkeletonTest,
       CreatesSkeletonComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::SkeletonAsset> data{};

  static constexpr uint32_t NumJoints = 5;

  for (uint32_t i = 0; i < NumJoints; ++i) {
    float fi = static_cast<float>(i);

    data.data.jointLocalPositions.push_back(glm::vec3(fi));
    data.data.jointLocalRotations.push_back(glm::quat(fi, fi, fi, fi));
    data.data.jointLocalScales.push_back(glm::vec3(fi * 5.0f));
    data.data.jointParents.push_back(i - 1);
    data.data.jointInverseBindMatrices.push_back(glm::mat4(fi));
    data.data.jointNames.push_back("J" + std::to_string(i));
  }

  data.relativePath = liquid::Path("test") / "hello.lqskel";
  auto handle = assetRegistry.getSkeletons().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["skeleton"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::SkeletonComponent>(entity));

  const auto &skeleton = entityDatabase.get<liquid::SkeletonComponent>(entity);
  EXPECT_EQ(skeleton.assetHandle, handle);

  EXPECT_EQ(skeleton.numJoints, NumJoints);
  for (uint32_t i = 0; i < NumJoints; ++i) {
    float fi = static_cast<float>(i);

    EXPECT_EQ(skeleton.jointLocalPositions.at(i),
              data.data.jointLocalPositions.at(i));
    EXPECT_EQ(skeleton.jointLocalRotations.at(i),
              data.data.jointLocalRotations.at(i));
    EXPECT_EQ(skeleton.jointLocalScales.at(i),
              data.data.jointLocalScales.at(i));
    EXPECT_EQ(skeleton.jointParents.at(i), data.data.jointParents.at(i));
    EXPECT_EQ(skeleton.jointInverseBindMatrices.at(i),
              data.data.jointInverseBindMatrices.at(i));
    EXPECT_EQ(skeleton.jointNames.at(i), data.data.jointNames.at(i));

    EXPECT_EQ(skeleton.jointFinalTransforms.at(i), glm::mat4{1.0f});
    EXPECT_EQ(skeleton.jointWorldTransforms.at(i), glm::mat4{1.0f});
  }
}

using SceneLoaderLightTest = SceneLoaderTest;

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLightComponent>(entity));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLightComponent>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightTypeIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLightComponent>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightTypeIsUndefined) {
  static constexpr uint32_t InvalidStart = 1;

  // Check for 10 items
  static constexpr uint32_t Size = 10;

  for (uint32_t i = InvalidStart; i < InvalidStart + Size; ++i) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = i;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLightComponent>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       TriesToFillDirectionalComponentValuesIfLightPropertiesAreInvalid) {

  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  liquid::DirectionalLightComponent defaults{};

  glm::vec4 validColor{0.5f};
  float validIntensity = 3.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["color"] = invalidNode;
    node["components"]["light"]["intensity"] = validIntensity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLightComponent>(entity));

    const auto &component =
        entityDatabase.get<liquid::DirectionalLightComponent>(entity);

    EXPECT_EQ(component.color, defaults.color);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.direction, glm::vec3(0.0f));
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["color"] = validColor;
    node["components"]["light"]["intensity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLightComponent>(entity));

    const auto &component =
        entityDatabase.get<liquid::DirectionalLightComponent>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, defaults.intensity);
    EXPECT_EQ(component.direction, glm::vec3(0.0f));
  }
}

TEST_F(SceneLoaderMeshTest,
       CreatesDirectionalLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["components"]["light"]["type"] = 0;
  node["components"]["light"]["color"] = glm::vec4(2.0f);
  node["components"]["light"]["intensity"] = 3.5f;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLightComponent>(entity));

  const auto &component =
      entityDatabase.get<liquid::DirectionalLightComponent>(entity);

  EXPECT_EQ(component.color, glm::vec4(2.0f));
  EXPECT_EQ(component.intensity, 3.5f);
  EXPECT_EQ(component.direction, glm::vec3(0.0f));
}

using SceneLoaderCameraTest = SceneLoaderTest;

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateCameraComponentIfCameraFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::CameraComponent>(entity));
  EXPECT_FALSE(entityDatabase.has<liquid::PerspectiveLensComponent>(entity));
  EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatioComponent>(entity));
}

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateCameraComponentIfCameraFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::CameraComponent>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLightComponent>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatioComponent>(entity));
  }
}

TEST_F(SceneLoaderCameraTest,
       TriesToFillAllPossibleValuesIfCameraFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  liquid::PerspectiveLensComponent defaults{};

  float validFov = 65.0f;
  float validNear = 0.5f;
  float validFar = 1000.0f;
  float validAspectRatio = 2.0f;

  // FOV
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"]["fov"] = invalidNode;
    node["components"]["camera"]["near"] = validNear;
    node["components"]["camera"]["far"] = validFar;
    node["components"]["camera"]["aspectRatio"] = validAspectRatio;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::PerspectiveLensComponent>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatioComponent>(entity));

    const auto &component =
        entityDatabase.get<liquid::PerspectiveLensComponent>(entity);

    EXPECT_EQ(component.fovY, defaults.fovY);
    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
  }

  // Near
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"]["fov"] = validFov;
    node["components"]["camera"]["near"] = invalidNode;
    node["components"]["camera"]["far"] = validFar;
    node["components"]["camera"]["aspectRatio"] = validAspectRatio;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::PerspectiveLensComponent>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatioComponent>(entity));

    const auto &component =
        entityDatabase.get<liquid::PerspectiveLensComponent>(entity);

    EXPECT_EQ(component.fovY, validFov);
    EXPECT_EQ(component.near, defaults.near);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
  }

  // Far
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"]["fov"] = validFov;
    node["components"]["camera"]["near"] = validNear;
    node["components"]["camera"]["far"] = invalidNode;
    node["components"]["camera"]["aspectRatio"] = validAspectRatio;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::PerspectiveLensComponent>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatioComponent>(entity));

    const auto &component =
        entityDatabase.get<liquid::PerspectiveLensComponent>(entity);

    EXPECT_EQ(component.fovY, validFov);
    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, defaults.far);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
  }

  // Aspect ratio
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"]["fov"] = validFov;
    node["components"]["camera"]["near"] = validNear;
    node["components"]["camera"]["far"] = validFar;
    node["components"]["camera"]["aspectRatio"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::PerspectiveLensComponent>(entity));
    EXPECT_TRUE(entityDatabase.has<liquid::AutoAspectRatioComponent>(entity));

    const auto &component =
        entityDatabase.get<liquid::PerspectiveLensComponent>(entity);

    EXPECT_EQ(component.fovY, validFov);
    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, defaults.aspectRatio);
  }
}

TEST_F(SceneLoaderCameraTest, CreatesCameraComponentWithDefaultValues) {
  liquid::CameraComponent defaults{};
  auto [node, entity] = createNode();
  node["components"]["camera"]["fov"] = 20.0f;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::CameraComponent>(entity));
  const auto &component = entityDatabase.get<liquid::CameraComponent>(entity);

  EXPECT_EQ(component.projectionMatrix, defaults.projectionMatrix);
  EXPECT_EQ(component.viewMatrix, defaults.viewMatrix);
  EXPECT_EQ(component.projectionViewMatrix, defaults.projectionViewMatrix);
}

TEST_F(SceneLoaderCameraTest,
       CreatesAutoAspectRatioComponentIfAspectRatioIsAuto) {
  auto [node, entity] = createNode();
  node["components"]["camera"]["aspectRatio"] = "auto";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_TRUE(entityDatabase.has<liquid::AutoAspectRatioComponent>(entity));
}

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateAutoAspectRatioComponentIfAspectRatioIsFixed) {
  auto [node, entity] = createNode();
  node["components"]["camera"]["aspectRatio"] = 2.0f;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatioComponent>(entity));
}

TEST_F(SceneLoaderCameraTest, CreatesCameraComponentWithFileDataIfValidField) {
  float validFov = 65.0f;
  float validNear = 0.5f;
  float validFar = 1000.0f;
  float validAspectRatio = 2.0f;

  auto [node, entity] = createNode();
  node["components"]["camera"]["fov"] = validFov;
  node["components"]["camera"]["near"] = validNear;
  node["components"]["camera"]["far"] = validFar;
  node["components"]["camera"]["aspectRatio"] = validAspectRatio;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  const auto &lens =
      entityDatabase.get<liquid::PerspectiveLensComponent>(entity);

  EXPECT_EQ(lens.fovY, validFov);
  EXPECT_EQ(lens.near, validNear);
  EXPECT_EQ(lens.far, validFar);
  EXPECT_EQ(lens.aspectRatio, validAspectRatio);
}

using SceneLoaderAudioTest = SceneLoaderTest;

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfAudioFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::AudioSourceComponent>(entity));
}

TEST_F(SceneLoaderAudioTest, DoesNotCreateAudioComponentIfAudioFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["audio"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSourceComponent>(entity));
  }
}

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfAudioSourceFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["audio"]["source"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSourceComponent>(entity));
  }
}

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfNoAudioHandleInRegistry) {
  liquid::AssetData<liquid::AudioAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getAudios().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["audio"]["source"] = "hello.lqmesh";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::AudioSourceComponent>(entity));
}

TEST_F(SceneLoaderAudioTest, CreatesAudioComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::AudioAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getAudios().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["audio"]["source"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::AudioSourceComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::AudioSourceComponent>(entity).source,
            handle);
}

using SceneLoaderScriptTest = SceneLoaderTest;

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfScriptFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::ScriptingComponent>(entity));
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfScriptFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["script"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::ScriptingComponent>(entity));
  }
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfNoScriptHandleInRegistry) {
  liquid::AssetData<liquid::LuaScriptAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lua";
  auto handle = assetRegistry.getLuaScripts().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["script"] = "hello.lua";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::ScriptingComponent>(entity));
}

TEST_F(SceneLoaderScriptTest, CreatesScriptComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::LuaScriptAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lua";
  auto handle = assetRegistry.getLuaScripts().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["script"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::ScriptingComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::ScriptingComponent>(entity).handle,
            handle);
}

using SceneLoaderTextTest = SceneLoaderTest;

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::TextComponent>(entity));
}

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["text"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSourceComponent>(entity));
  }
}

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFontIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["text"]["font"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::TextComponent>(entity));
  }
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateTextComponentIfNoFontHandleInRegistry) {
  liquid::AssetData<liquid::FontAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.ttf";
  auto handle = assetRegistry.getFonts().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["text"]["font"] = "hello.ttf";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::TextComponent>(entity));
}

TEST_F(SceneLoaderScriptTest,
       TriesToFillTextComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  liquid::AssetData<liquid::FontAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.ttf";
  auto handle = assetRegistry.getFonts().addAsset(data);

  liquid::TextComponent defaults{};

  auto validContent = "Hello world";
  auto validLineHeight = 20.0f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["text"]["lineHeight"] = invalidNode;
    node["components"]["text"]["content"] = validContent;
    node["components"]["text"]["font"] = data.relativePath.string();

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::TextComponent>(entity));
    const auto &text = entityDatabase.get<liquid::TextComponent>(entity);

    EXPECT_EQ(text.text, validContent);
    EXPECT_EQ(text.lineHeight, defaults.lineHeight);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["text"]["lineHeight"] = validLineHeight;
    node["components"]["text"]["content"] = invalidNode;
    node["components"]["text"]["font"] = data.relativePath.string();

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::TextComponent>(entity));
    const auto &text = entityDatabase.get<liquid::TextComponent>(entity);

    EXPECT_EQ(text.text, defaults.text);
    EXPECT_EQ(text.lineHeight, validLineHeight);
  }
}

TEST_F(SceneLoaderTextTest, CreatesTextComponentWithFileDataIfValidField) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  liquid::AssetData<liquid::FontAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.ttf";
  auto handle = assetRegistry.getFonts().addAsset(data);

  liquid::TextComponent defaults{};

  auto validContent = "Hello world";
  auto validLineHeight = 20.0f;

  auto [node, entity] = createNode();
  node["components"]["text"]["lineHeight"] = validLineHeight;
  node["components"]["text"]["content"] = validContent;
  node["components"]["text"]["font"] = data.relativePath.string();

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::TextComponent>(entity));
  const auto &text = entityDatabase.get<liquid::TextComponent>(entity);

  EXPECT_EQ(text.text, validContent);
  EXPECT_EQ(text.lineHeight, validLineHeight);
  EXPECT_EQ(text.font, handle);
}

using SceneLoaderRigidBodyTest = SceneLoaderTest;

TEST_F(SceneLoaderRigidBodyTest,
       DoesNotCreateRigidBodyComponentIfRigidBodyFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::RigidBodyComponent>(entity));
}

TEST_F(SceneLoaderRigidBodyTest,
       DoesNotCreateRigidBodyComponentIfRigidBodyFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["rigidBody"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSourceComponent>(entity));
  }
}

TEST_F(SceneLoaderRigidBodyTest,
       TriesToFillRigidBodyComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  liquid::RigidBodyComponent defaultComponent{};
  auto defaults = defaultComponent.dynamicDesc;

  auto validMass = 2.5f;
  auto validInertia = glm::vec3(2.5f);
  auto validGravity = true;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["rigidBody"]["mass"] = invalidNode;
    node["components"]["rigidBody"]["inertia"] = validInertia;
    node["components"]["rigidBody"]["gravity"] = validGravity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::RigidBodyComponent>(entity));
    const auto &rigidBody =
        entityDatabase.get<liquid::RigidBodyComponent>(entity).dynamicDesc;

    EXPECT_EQ(rigidBody.mass, defaults.mass);
    EXPECT_EQ(rigidBody.inertia, validInertia);
    EXPECT_EQ(rigidBody.applyGravity, validGravity);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["rigidBody"]["mass"] = validMass;
    node["components"]["rigidBody"]["inertia"] = invalidNode;
    node["components"]["rigidBody"]["gravity"] = validGravity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::RigidBodyComponent>(entity));
    const auto &rigidBody =
        entityDatabase.get<liquid::RigidBodyComponent>(entity).dynamicDesc;

    EXPECT_EQ(rigidBody.mass, validMass);
    EXPECT_EQ(rigidBody.inertia, defaults.inertia);
    EXPECT_EQ(rigidBody.applyGravity, validGravity);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["rigidBody"]["mass"] = validMass;
    node["components"]["rigidBody"]["inertia"] = validInertia;
    node["components"]["rigidBody"]["gravity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::RigidBodyComponent>(entity));
    const auto &rigidBody =
        entityDatabase.get<liquid::RigidBodyComponent>(entity).dynamicDesc;

    EXPECT_EQ(rigidBody.mass, validMass);
    EXPECT_EQ(rigidBody.inertia, validInertia);
    EXPECT_EQ(rigidBody.applyGravity, defaults.applyGravity);
  }
}

TEST_F(SceneLoaderRigidBodyTest,
       CreatesRigidBodyComponentWithFileDataIfValidField) {
  auto validMass = 2.5f;
  auto validInertia = glm::vec3(2.5f);
  auto validGravity = true;

  auto [node, entity] = createNode();
  node["components"]["rigidBody"]["mass"] = validMass;
  node["components"]["rigidBody"]["inertia"] = validInertia;
  node["components"]["rigidBody"]["applyGravity"] = validGravity;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::RigidBodyComponent>(entity));
  const auto &rigidBody =
      entityDatabase.get<liquid::RigidBodyComponent>(entity).dynamicDesc;

  EXPECT_EQ(rigidBody.mass, validMass);
  EXPECT_EQ(rigidBody.inertia, validInertia);
  EXPECT_EQ(rigidBody.applyGravity, validGravity);
}

using SceneLoaderCollidableTest = SceneLoaderTest;

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::CollidableComponent>(entity));
}

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSourceComponent>(entity));
  }
}

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableShapeIsUnknown) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  node["components"]["collidable"]["shape"] = "unknown";

  EXPECT_FALSE(entityDatabase.has<liquid::CollidableComponent>(entity));
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableBoxComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = liquid::PhysicsGeometryBox{};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"]["shape"] = "box";
    node["components"]["collidable"]["halfExtents"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
    const auto &collidable = std::get<liquid::PhysicsGeometryBox>(
        entityDatabase.get<liquid::CollidableComponent>(entity)
            .geometryDesc.params);

    EXPECT_EQ(collidable.halfExtents, defaults.halfExtents);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesBoxCollidableWithFileDataIfValidField) {
  auto validHalfExtents = glm::vec3(2.5f);

  auto [node, entity] = createNode();
  node["components"]["collidable"]["shape"] = "box";
  node["components"]["collidable"]["halfExtents"] = validHalfExtents;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
  const auto &collidable = std::get<liquid::PhysicsGeometryBox>(
      entityDatabase.get<liquid::CollidableComponent>(entity)
          .geometryDesc.params);

  EXPECT_EQ(collidable.halfExtents, validHalfExtents);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableSphereComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = liquid::PhysicsGeometrySphere{};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"]["shape"] = "sphere";
    node["components"]["collidable"]["radius"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
    const auto &collidable = std::get<liquid::PhysicsGeometrySphere>(
        entityDatabase.get<liquid::CollidableComponent>(entity)
            .geometryDesc.params);

    EXPECT_EQ(collidable.radius, defaults.radius);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesSphereCollidableWithFileDataIfValidField) {
  auto validRadius = 2.5f;

  auto [node, entity] = createNode();
  node["components"]["collidable"]["shape"] = "sphere";
  node["components"]["collidable"]["radius"] = validRadius;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
  const auto &collidable = std::get<liquid::PhysicsGeometrySphere>(
      entityDatabase.get<liquid::CollidableComponent>(entity)
          .geometryDesc.params);

  EXPECT_EQ(collidable.radius, validRadius);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableCapsuleComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = liquid::PhysicsGeometryCapsule{};

  auto validHalfHeight = 3.5f;
  auto validRadius = 2.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"]["shape"] = "capsule";
    node["components"]["collidable"]["radius"] = invalidNode;
    node["components"]["collidable"]["halfHeight"] = validHalfHeight;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
    const auto &collidable = std::get<liquid::PhysicsGeometryCapsule>(
        entityDatabase.get<liquid::CollidableComponent>(entity)
            .geometryDesc.params);

    EXPECT_EQ(collidable.radius, defaults.radius);
    EXPECT_EQ(collidable.halfHeight, validHalfHeight);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"]["shape"] = "capsule";
    node["components"]["collidable"]["radius"] = validRadius;
    node["components"]["collidable"]["halfHeight"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
    const auto &collidable = std::get<liquid::PhysicsGeometryCapsule>(
        entityDatabase.get<liquid::CollidableComponent>(entity)
            .geometryDesc.params);

    EXPECT_EQ(collidable.radius, validRadius);
    EXPECT_EQ(collidable.halfHeight, defaults.halfHeight);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesCapsuleCollidableWithFileDataIfValidField) {
  auto validHalfHeight = 3.5f;
  auto validRadius = 2.5f;

  auto [node, entity] = createNode();
  node["components"]["collidable"]["shape"] = "capsule";
  node["components"]["collidable"]["radius"] = validRadius;
  node["components"]["collidable"]["halfHeight"] = validHalfHeight;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
  const auto &collidable = std::get<liquid::PhysicsGeometryCapsule>(
      entityDatabase.get<liquid::CollidableComponent>(entity)
          .geometryDesc.params);

  EXPECT_EQ(collidable.radius, validRadius);
  EXPECT_EQ(collidable.halfHeight, validHalfHeight);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableComponentMaterialsIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = liquid::PhysicsMaterialDesc{};

  auto validDynamicFriction = 3.5f;
  auto validRestitution = 2.5f;
  auto validStaticFriction = 1.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["components"]["collidable"]["shape"] = "box";
    node["components"]["collidable"]["dynamicFriction"] = invalidNode;
    node["components"]["collidable"]["restitution"] = validRestitution;
    node["components"]["collidable"]["staticFriction"] = validStaticFriction;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
    const auto &material =
        entityDatabase.get<liquid::CollidableComponent>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, defaults.dynamicFriction);
    EXPECT_EQ(material.restitution, validRestitution);
    EXPECT_EQ(material.staticFriction, validStaticFriction);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["components"]["collidable"]["shape"] = "sphere";
    node["components"]["collidable"]["dynamicFriction"] = validDynamicFriction;
    node["components"]["collidable"]["restitution"] = invalidNode;
    node["components"]["collidable"]["staticFriction"] = validStaticFriction;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
    const auto &material =
        entityDatabase.get<liquid::CollidableComponent>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
    EXPECT_EQ(material.restitution, defaults.restitution);
    EXPECT_EQ(material.staticFriction, validStaticFriction);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["components"]["collidable"]["shape"] = "capsule";
    node["components"]["collidable"]["dynamicFriction"] = validDynamicFriction;
    node["components"]["collidable"]["restitution"] = validRestitution;
    node["components"]["collidable"]["staticFriction"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
    const auto &material =
        entityDatabase.get<liquid::CollidableComponent>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
    EXPECT_EQ(material.restitution, validRestitution);
    EXPECT_EQ(material.staticFriction, defaults.staticFriction);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesCollidableMaterialsWithFileDataIfValidField) {
  auto validDynamicFriction = 3.5f;
  auto validRestitution = 2.5f;
  auto validStaticFriction = 1.5f;

  auto [node, entity] = createNode();
  // Shape does not matter here
  node["components"]["collidable"]["shape"] = "plane";
  node["components"]["collidable"]["dynamicFriction"] = validDynamicFriction;
  node["components"]["collidable"]["restitution"] = validRestitution;
  node["components"]["collidable"]["staticFriction"] = validStaticFriction;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::CollidableComponent>(entity));
  const auto &material =
      entityDatabase.get<liquid::CollidableComponent>(entity).materialDesc;

  EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
  EXPECT_EQ(material.restitution, validRestitution);
  EXPECT_EQ(material.staticFriction, validStaticFriction);
}

using SceneLoaderParentTest = SceneLoaderTest;

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentFieldDoesNotExist) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::ParentComponent>(entity));
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["transform"]["parent"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::ParentComponent>(entity));
  }
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentDoesNotExist) {
  static constexpr uint64_t NonExistentId = 255;
  auto [parentNode, parentEntity] = createNode();

  auto [node, entity] = createNode();
  node["components"]["transform"]["parent"] = NonExistentId;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::ParentComponent>(entity));
  EXPECT_FALSE(entityDatabase.has<liquid::ChildrenComponent>(parentEntity));
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentIsNotCreatedWithSceneLoader) {
  static constexpr uint64_t ParentId = 255;

  auto parentEntity = entityDatabase.create();
  entityDatabase.set<liquid::IdComponent>(parentEntity, {ParentId});

  auto [node, entity] = createNode();
  node["components"]["transform"]["parent"] = ParentId;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::ParentComponent>(entity));
  EXPECT_FALSE(entityDatabase.has<liquid::ChildrenComponent>(parentEntity));
}

TEST_F(SceneLoaderParentTest, CreatesParentComponentIfParentEntityExists) {
  auto [parentNode, parentEntity] = createNode();

  auto [node, entity] = createNode();
  node["components"]["transform"]["parent"] = parentNode["id"];
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::ParentComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::ParentComponent>(entity).parent,
            parentEntity);
  EXPECT_TRUE(entityDatabase.has<liquid::ChildrenComponent>(parentEntity));
  EXPECT_EQ(entityDatabase.get<liquid::ChildrenComponent>(parentEntity)
                .children.at(0),
            entity);
}

TEST_F(SceneLoaderParentTest,
       AddsChildToParentComponentIfChildrenComponentAlreadyExists) {
  auto [parentNode, parentEntity] = createNode();
  entityDatabase.set<liquid::ChildrenComponent>(parentEntity,
                                                {{liquid::EntityNull}});

  auto [node, entity] = createNode();
  node["components"]["transform"]["parent"] = parentNode["id"];
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::ParentComponent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::ParentComponent>(entity).parent,
            parentEntity);
  EXPECT_TRUE(entityDatabase.has<liquid::ChildrenComponent>(parentEntity));
  EXPECT_EQ(entityDatabase.get<liquid::ChildrenComponent>(parentEntity)
                .children.at(1),
            entity);
}
