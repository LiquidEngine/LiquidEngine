#include "liquid/core/Base.h"
#include "liquid-tests/Testing.h"

#include "liquid/entity/EntityDatabase.h"
#include "liquid/scene/private/SceneLoader.h"

class SceneLoaderTest : public ::testing::Test {
public:
  SceneLoaderTest() : sceneLoader(assetRegistry, entityDatabase) {}

  std::pair<YAML::Node, liquid::Entity> createNode(bool create = true) {
    auto id = lastId++;

    YAML::Node node;
    node["id"] = id;
    node["version"] = "0.1";
    node["components"] = YAML::Node(YAML::NodeType::Map);

    if (create) {
      auto entity = entityDatabase.create();
      entityIdCache.insert_or_assign(id, entity);

      entityDatabase.set<liquid::Id>(entity, {id});

      return {node, entity};
    }

    return {node, liquid::Entity::Null};
  }

public:
  liquid::AssetRegistry assetRegistry;
  liquid::EntityDatabase entityDatabase;
  liquid::detail::EntityIdCache entityIdCache;
  liquid::detail::SceneLoader sceneLoader;

private:
  uint32_t lastId = 1;
};

using SceneLoaderNameTest = SceneLoaderTest;

TEST_F(SceneLoaderNameTest, CreatesAutoGeneratedNameIfNameFieldIsNotDefined) {
  auto [node, entity] = createNode();
  auto untitledName = "Untitled " + node["id"].as<liquid::String>();

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Name>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::Name>(entity).name, untitledName);
}

TEST_F(SceneLoaderNameTest, CreatesAutoGeneratedNameIfNameFieldIsInvalid) {
  auto [node, entity] = createNode();
  auto untitledName = "Untitled " + node["id"].as<liquid::String>();

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Name>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::Name>(entity).name, untitledName);
}

TEST_F(SceneLoaderNameTest, CreatesNameComponentWithFileDataIfValidField) {
  auto [node, entity] = createNode();
  node["components"]["name"] = "Hello World";

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Name>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::Name>(entity).name, "Hello World");
}

using SceneLoaderTransformTest = SceneLoaderTest;

TEST_F(SceneLoaderTransformTest, CreatesIdentityWorldTransform) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::WorldTransform>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::WorldTransform>(entity).worldTransform,
            glm::mat4{1.0f});
}

TEST_F(SceneLoaderTransformTest,
       CreatesEmptyTransformComponentIfTransformFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  liquid::LocalTransform expected{};

  EXPECT_TRUE(entityDatabase.has<liquid::LocalTransform>(entity));

  const auto &actual = entityDatabase.get<liquid::LocalTransform>(entity);

  EXPECT_EQ(actual.localPosition, expected.localPosition);
  EXPECT_EQ(actual.localRotation, expected.localRotation);
  EXPECT_EQ(actual.localScale, expected.localScale);

  EXPECT_EQ(entityDatabase.get<liquid::WorldTransform>(entity).worldTransform,
            glm::mat4{1.0f});
}

TEST_F(SceneLoaderTransformTest,
       TriesToFillAllPossibleValuesIfInvalidStructure) {

  liquid::LocalTransform defaults{};
  glm::vec3 validPosition(2.0f);
  glm::quat validRotation(0.0f, 1.0f, 0.0f, 0.0f);
  glm::vec3 validScale(4.5f);

  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["transform"]["position"] = value;
    node["components"]["transform"]["rotation"] = validRotation;
    node["components"]["transform"]["scale"] = validScale;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    const auto &transform = entityDatabase.get<liquid::LocalTransform>(entity);

    EXPECT_EQ(transform.localPosition, defaults.localPosition);
    EXPECT_EQ(transform.localRotation, validRotation);
    EXPECT_EQ(transform.localScale, validScale);
  }

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["transform"]["position"] = validPosition;
    node["components"]["transform"]["rotation"] = value;
    node["components"]["transform"]["scale"] = validScale;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    const auto &transform = entityDatabase.get<liquid::LocalTransform>(entity);

    EXPECT_EQ(transform.localPosition, validPosition);
    EXPECT_EQ(transform.localRotation, defaults.localRotation);
    EXPECT_EQ(transform.localScale, validScale);
  }

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["transform"]["position"] = validPosition;
    node["components"]["transform"]["rotation"] = validRotation;
    node["components"]["transform"]["scale"] = value;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    const auto &transform = entityDatabase.get<liquid::LocalTransform>(entity);

    EXPECT_EQ(transform.localPosition, validPosition);
    EXPECT_EQ(transform.localRotation, validRotation);
    EXPECT_EQ(transform.localScale, defaults.localScale);
  }
}

TEST_F(SceneLoaderTransformTest,
       CreatesTransformComponentWithFileDataIfValidField) {
  liquid::LocalTransform defaults{};
  glm::vec3 validPosition(2.0f);
  glm::quat validRotation(0.0f, 1.0f, 0.0f, 0.0f);
  glm::vec3 validScale(4.5f);

  auto [node, entity] = createNode();
  node["components"]["transform"]["position"] = validPosition;
  node["components"]["transform"]["rotation"] = validRotation;
  node["components"]["transform"]["scale"] = validScale;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  const auto &transform = entityDatabase.get<liquid::LocalTransform>(entity);
  EXPECT_EQ(transform.localPosition, validPosition);
  EXPECT_EQ(transform.localRotation, validRotation);
  EXPECT_EQ(transform.localScale, validScale);
}

using SceneLoaderMeshTest = SceneLoaderTest;

TEST_F(SceneLoaderMeshTest, DoesNotCreateMeshComponentIfMeshFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Mesh>(entity));
}

TEST_F(SceneLoaderMeshTest, DoesNotCreateMeshComponentIfMeshFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["mesh"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::Mesh>(entity));
  }
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateMeshComponentIfNoMeshHandleInRegistry) {
  liquid::AssetData<liquid::MeshAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["mesh"] = "hello.lqmesh";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Mesh>(entity));
}

TEST_F(SceneLoaderMeshTest, CreatesMeshComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::MeshAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["mesh"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Mesh>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::Mesh>(entity).handle, handle);
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateSkinnedMeshComponentIfMeshFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::SkinnedMesh>(entity));
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateSkinnedMeshComponentIfMeshFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skinnedMesh"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::SkinnedMesh>(entity));
  }
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateSkinnedMeshComponentIfNoSkinnedMeshHandleInRegistry) {
  liquid::AssetData<liquid::SkinnedMeshAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getSkinnedMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["skinnedMesh"] = "hello.lqmesh";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::SkinnedMesh>(entity));
}

TEST_F(SceneLoaderMeshTest,
       CreatesSkinnedMeshComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::SkinnedMeshAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getSkinnedMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["skinnedMesh"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::SkinnedMesh>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::SkinnedMesh>(entity).handle, handle);
}

using SceneLoaderSkeletonTest = SceneLoaderTest;

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfSkeletonFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Skeleton>(entity));
}

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfSkeletonFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skeleton"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::Skeleton>(entity));
  }
}

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfNoSkeletonHandleInRegistry) {
  liquid::AssetData<liquid::SkeletonAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqskel";
  auto handle = assetRegistry.getSkeletons().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["skeleton"] = "hello.lqskel";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Skeleton>(entity));
}

TEST_F(SceneLoaderSkeletonTest,
       CreatesSkeletonComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::SkeletonAsset> data{};

  static constexpr uint32_t NumJoints = 5;

  for (uint32_t i = 0; i < NumJoints; ++i) {
    float fi = static_cast<float>(i);

    data.data.jointLocalPositions.push_back(glm::vec3(fi));
    data.data.jointLocalRotations.push_back(glm::quat(fi, fi, fi, fi));
    data.data.jointLocalScales.push_back(glm::vec3(fi * 5.0f));
    data.data.jointParents.push_back(i - 1);
    data.data.jointInverseBindMatrices.push_back(glm::mat4(fi));
    data.data.jointNames.push_back("J" + std::to_string(i));
  }

  data.relativePath = liquid::Path("test") / "hello.lqskel";
  auto handle = assetRegistry.getSkeletons().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["skeleton"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Skeleton>(entity));

  const auto &skeleton = entityDatabase.get<liquid::Skeleton>(entity);
  EXPECT_EQ(skeleton.assetHandle, handle);

  EXPECT_EQ(skeleton.numJoints, NumJoints);
  for (uint32_t i = 0; i < NumJoints; ++i) {
    float fi = static_cast<float>(i);

    EXPECT_EQ(skeleton.jointLocalPositions.at(i),
              data.data.jointLocalPositions.at(i));
    EXPECT_EQ(skeleton.jointLocalRotations.at(i),
              data.data.jointLocalRotations.at(i));
    EXPECT_EQ(skeleton.jointLocalScales.at(i),
              data.data.jointLocalScales.at(i));
    EXPECT_EQ(skeleton.jointParents.at(i), data.data.jointParents.at(i));
    EXPECT_EQ(skeleton.jointInverseBindMatrices.at(i),
              data.data.jointInverseBindMatrices.at(i));
    EXPECT_EQ(skeleton.jointNames.at(i), data.data.jointNames.at(i));

    EXPECT_EQ(skeleton.jointFinalTransforms.at(i), glm::mat4{1.0f});
    EXPECT_EQ(skeleton.jointWorldTransforms.at(i), glm::mat4{1.0f});
  }
}

using SceneLoaderAnimatorTest = SceneLoaderTest;

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAnimatorFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<liquid::Animator>(entity));
}

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAnimatorFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["animator"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<liquid::Animator>(entity));
  }
}

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAnimationsFieldIsNotSequence) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["animator"]["animations"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<liquid::Animator>(entity));
  }
}

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAnimationsFieldIsEmpty) {
  auto [node, entity] = createNode();
  node["components"]["animator"]["animations"] =
      YAML::Node(YAML::NodeType::Sequence);
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_FALSE(entityDatabase.has<liquid::Animator>(entity));
}

TEST_F(
    SceneLoaderAnimatorTest,
    DoesNotCreateAnimatorComponentIfNoAnimationsAfterRemovingInvalidSequenceItems) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence)};

  auto [node, entity] = createNode();
  node["components"]["animator"]["animations"] =
      YAML::Node(YAML::NodeType::Sequence);

  size_t index = 0;
  for (const auto &invalidNode : invalidNodes) {
    node["components"]["animator"]["animations"].push_back(invalidNode);
  }

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<liquid::Animator>(entity));
}

TEST_F(
    SceneLoaderAnimatorTest,
    DoesNotCreateAnimatorComponentIfNoAnimationsAfterRemovingNonExistentAssets) {
  auto [node, entity] = createNode();
  node["components"]["animator"]["animations"] =
      YAML::Node(YAML::NodeType::Sequence);

  node["components"]["animator"]["animations"].push_back(
      "non-existent-sequence.lqanim");

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<liquid::Animator>(entity));
}

TEST_F(SceneLoaderAnimatorTest, CreatesAnimatorComponentIfAllFieldsAreValid) {
  liquid::AssetData<liquid::AnimationAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqanim";
  auto handle = assetRegistry.getAnimations().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["animator"]["animations"] =
      YAML::Node(YAML::NodeType::Sequence);

  node["components"]["animator"]["animations"].push_back(
      data.relativePath.string());

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<liquid::Animator>(entity));

  const auto &animator = entityDatabase.get<liquid::Animator>(entity);
  EXPECT_EQ(animator.animations.size(), 1);
  EXPECT_EQ(animator.animations.at(0), handle);
  EXPECT_EQ(animator.currentAnimation, 0);
  EXPECT_EQ(animator.loop, false);
  EXPECT_EQ(animator.playing, false);
  EXPECT_EQ(animator.normalizedTime, 0);
}

TEST_F(SceneLoaderAnimatorTest,
       CreatesAnimatorComponentWithInvalidAnimationsRemoved) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence)};

  auto [node, entity] = createNode();
  node["components"]["animator"]["animations"] =
      YAML::Node(YAML::NodeType::Sequence);

  static constexpr size_t AnimationsCount = 5;

  std::vector<liquid::AnimationAssetHandle> validAnimationHandles;

  size_t index = 0;

  for (size_t i = 0; i < AnimationsCount; ++i) {
    liquid::AssetData<liquid::AnimationAsset> data{};
    data.relativePath =
        liquid::Path("test") / ("hello" + std::to_string(i) + ".lqanim");
    validAnimationHandles.push_back(
        assetRegistry.getAnimations().addAsset(data));
    node["components"]["animator"]["animations"].push_back(
        data.relativePath.string());
  }

  for (auto invalidNode : invalidNodes) {
    node["components"]["animator"]["animations"].push_back(invalidNode);
  }

  for (size_t i = 0; i < AnimationsCount; ++i) {
    node["components"]["animator"]["animations"].push_back(
        "invalid-animation-" + std::to_string(i) + ".lqanim");
  }

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<liquid::Animator>(entity));

  const auto &animator = entityDatabase.get<liquid::Animator>(entity);
  EXPECT_EQ(animator.animations.size(), validAnimationHandles.size());
  for (size_t i = 0; i < animator.animations.size(); ++i) {
    EXPECT_EQ(animator.animations.at(i), validAnimationHandles.at(i));
  }
  EXPECT_EQ(animator.currentAnimation, 0);
  EXPECT_EQ(animator.loop, false);
  EXPECT_EQ(animator.playing, false);
  EXPECT_EQ(animator.normalizedTime, 0);
}

TEST_F(SceneLoaderAnimatorTest,
       SetsAnimatorComponentStartingAnimationToZeroIfInvalidField) {
  liquid::AssetData<liquid::AnimationAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqanim";
  auto handle = assetRegistry.getAnimations().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["animator"]["animations"] =
      YAML::Node(YAML::NodeType::Sequence);
  node["components"]["animator"]["animations"].push_back(
      data.relativePath.string());

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       YAML::Node("incorrect-value")};

  for (auto invalidNode : invalidNodes) {
    node["components"]["animator"]["startingAnimation"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);

    EXPECT_TRUE(entityDatabase.has<liquid::Animator>(entity));
    const auto &animator = entityDatabase.get<liquid::Animator>(entity);

    EXPECT_EQ(animator.currentAnimation, 0);
    entityDatabase.remove<liquid::Animator>(entity);
  }
}

TEST_F(
    SceneLoaderAnimatorTest,
    SetsAnimatorComponentStartingAnimationToZeroIfAnimationIndexIsOutOfBounds) {
  liquid::AssetData<liquid::AnimationAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqanim";
  auto handle = assetRegistry.getAnimations().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["animator"]["animations"] =
      YAML::Node(YAML::NodeType::Sequence);

  static constexpr size_t AnimationsCount = 5;

  size_t index = 0;

  for (size_t i = 0; i < AnimationsCount; ++i) {
    liquid::AssetData<liquid::AnimationAsset> data{};
    data.relativePath =
        liquid::Path("test") / ("hello" + std::to_string(i) + ".lqanim");
    assetRegistry.getAnimations().addAsset(data);
    node["components"]["animator"]["animations"].push_back(
        data.relativePath.string());
  }

  std::vector<YAML::Node> invalidNodes{YAML::Node(5), YAML::Node(6)};

  for (size_t i = 5; i < 10; ++i) {
    node["components"]["animator"]["startingAnimation"] = i;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    EXPECT_TRUE(entityDatabase.has<liquid::Animator>(entity));
    const auto &animator = entityDatabase.get<liquid::Animator>(entity);

    EXPECT_EQ(animator.currentAnimation, 0);
    entityDatabase.remove<liquid::Animator>(entity);
  }
}

TEST_F(SceneLoaderAnimatorTest,
       SetsAnimatorComponentStartingAnimationToFieldIndexIfValidIndex) {
  auto [node, entity] = createNode();
  node["components"]["animator"]["animations"] =
      YAML::Node(YAML::NodeType::Sequence);

  static constexpr size_t AnimationsCount = 5;

  size_t index = 0;

  for (size_t i = 0; i < AnimationsCount; ++i) {
    liquid::AssetData<liquid::AnimationAsset> data{};
    data.relativePath =
        liquid::Path("test") / ("hello" + std::to_string(i) + ".lqanim");
    assetRegistry.getAnimations().addAsset(data);
    node["components"]["animator"]["animations"].push_back(
        data.relativePath.string());
  }

  for (size_t i = 0; i < AnimationsCount; ++i) {
    node["components"]["animator"]["startingAnimation"] = i;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    EXPECT_TRUE(entityDatabase.has<liquid::Animator>(entity));
    const auto &animator = entityDatabase.get<liquid::Animator>(entity);

    EXPECT_EQ(animator.currentAnimation, static_cast<uint32_t>(i));
    entityDatabase.remove<liquid::Animator>(entity);
  }
}

using SceneLoaderLightTest = SceneLoaderTest;

TEST_F(SceneLoaderLightTest,
       DoesNotCreateLightComponentIfLightFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLight>(entity));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLight>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightTypeIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLight>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightTypeIsUndefined) {
  static constexpr uint32_t InvalidStart = 1;

  // Check for 10 items
  static constexpr uint32_t Size = 10;

  for (uint32_t i = InvalidStart; i < InvalidStart + Size; ++i) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = i;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLight>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       TriesToFillDirectionalComponentValuesIfLightPropertiesAreInvalid) {
  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  liquid::DirectionalLight defaults{};

  glm::vec4 validColor{0.5f};
  float validIntensity = 3.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["color"] = invalidNode;
    node["components"]["light"]["intensity"] = validIntensity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));

    const auto &component =
        entityDatabase.get<liquid::DirectionalLight>(entity);

    EXPECT_EQ(component.color, defaults.color);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.direction, glm::vec3(0.0f));
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["color"] = validColor;
    node["components"]["light"]["intensity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));

    const auto &component =
        entityDatabase.get<liquid::DirectionalLight>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, defaults.intensity);
    EXPECT_EQ(component.direction, glm::vec3(0.0f));
  }
}

TEST_F(SceneLoaderLightTest,
       CreatesDirectionalLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["components"]["light"]["type"] = 0;
  node["components"]["light"]["color"] = glm::vec4(2.0f);
  node["components"]["light"]["intensity"] = 3.5f;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));

  const auto &component = entityDatabase.get<liquid::DirectionalLight>(entity);

  EXPECT_EQ(component.color, glm::vec4(2.0f));
  EXPECT_EQ(component.intensity, 3.5f);
  EXPECT_EQ(component.direction, glm::vec3(0.0f));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateCascadedShadowMapForDirectionalLightIfFieldIsNotDefined) {
  auto [node, entity] = createNode();
  node["components"]["light"]["type"] = 0;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
  EXPECT_FALSE(entityDatabase.has<liquid::CascadedShadowMap>(entity));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateCascadedShadowMapForDirectionalLightIfShadowFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["shadow"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::CascadedShadowMap>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       TriesToFillCascadedShadowDataIfShadowPropertiesAreInvalid) {
  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["shadow"]["softShadows"] = invalidNode;
    node["components"]["light"]["shadow"]["splitLambda"] = 0.5f;
    node["components"]["light"]["shadow"]["numCascades"] = 2;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
    EXPECT_TRUE(entityDatabase.has<liquid::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<liquid::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.5f);
    EXPECT_EQ(component.numCascades, 2);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["shadow"]["softShadows"] = false;
    node["components"]["light"]["shadow"]["splitLambda"] = invalidNode;
    node["components"]["light"]["shadow"]["numCascades"] = 2;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
    EXPECT_TRUE(entityDatabase.has<liquid::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<liquid::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, false);
    EXPECT_EQ(component.splitLambda, 0.8f);
    EXPECT_EQ(component.numCascades, 2);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["shadow"]["softShadows"] = false;
    node["components"]["light"]["shadow"]["splitLambda"] = 0.5f;
    node["components"]["light"]["shadow"]["numCascades"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
    EXPECT_TRUE(entityDatabase.has<liquid::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<liquid::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, false);
    EXPECT_EQ(component.splitLambda, 0.5f);
    EXPECT_EQ(component.numCascades, 4);
  }

  // Split lambda > 1.0
  {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["shadow"]["splitLambda"] = 1.5f;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
    EXPECT_TRUE(entityDatabase.has<liquid::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<liquid::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 1.0f);
    EXPECT_EQ(component.numCascades, 4);
  }

  // Split lambda < 0.0
  {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["shadow"]["splitLambda"] = -0.5f;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
    EXPECT_TRUE(entityDatabase.has<liquid::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<liquid::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.0f);
    EXPECT_EQ(component.numCascades, 4);
  }

  // Num cascades > 6
  {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["shadow"]["numCascades"] = 10;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
    EXPECT_TRUE(entityDatabase.has<liquid::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<liquid::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.8f);
    EXPECT_EQ(component.numCascades, 6);
  }

  // Num cascades < 1
  {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 0;
    node["components"]["light"]["shadow"]["numCascades"] = 0;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
    EXPECT_TRUE(entityDatabase.has<liquid::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<liquid::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.8f);
    EXPECT_EQ(component.numCascades, 1);
  }
}

TEST_F(
    SceneLoaderLightTest,
    CreatesCascadedShadowMapForDirectionalLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["components"]["light"]["type"] = 0;
  node["components"]["light"]["shadow"]["softShadows"] = false;
  node["components"]["light"]["shadow"]["splitLambda"] = 0.5f;
  node["components"]["light"]["shadow"]["numCascades"] = 2;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::DirectionalLight>(entity));
  EXPECT_TRUE(entityDatabase.has<liquid::CascadedShadowMap>(entity));

  const auto &component = entityDatabase.get<liquid::CascadedShadowMap>(entity);

  EXPECT_EQ(component.softShadows, false);
  EXPECT_EQ(component.splitLambda, 0.5f);
  EXPECT_EQ(component.numCascades, 2);
}

TEST_F(
    SceneLoaderLightTest,
    TriesToFillPointLightComponentValuesIfLightPropertiesAreInvalidForPointLightType) {
  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  liquid::PointLight defaults{};

  glm::vec4 validColor{0.5f};
  float validIntensity = 3.5f;
  float validRange = 25.0f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 1;
    node["components"]["light"]["color"] = invalidNode;
    node["components"]["light"]["intensity"] = validIntensity;
    node["components"]["light"]["range"] = validRange;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<liquid::PointLight>(entity));

    const auto &component = entityDatabase.get<liquid::PointLight>(entity);

    EXPECT_EQ(component.color, defaults.color);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.range, validRange);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 1;
    node["components"]["light"]["color"] = validColor;
    node["components"]["light"]["intensity"] = invalidNode;
    node["components"]["light"]["range"] = validRange;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<liquid::PointLight>(entity));

    const auto &component = entityDatabase.get<liquid::PointLight>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, defaults.intensity);
    EXPECT_EQ(component.range, validRange);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["light"]["type"] = 1;
    node["components"]["light"]["color"] = validColor;
    node["components"]["light"]["intensity"] = validIntensity;
    node["components"]["light"]["range"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<liquid::PointLight>(entity));

    const auto &component = entityDatabase.get<liquid::PointLight>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.range, defaults.range);
  }
}

TEST_F(SceneLoaderLightTest, CreatesPointLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["components"]["light"]["type"] = 1;
  node["components"]["light"]["color"] = glm::vec4(2.0f);
  node["components"]["light"]["intensity"] = 3.5f;
  node["components"]["light"]["range"] = 25.0f;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<liquid::PointLight>(entity));

  const auto &component = entityDatabase.get<liquid::PointLight>(entity);

  EXPECT_EQ(component.color, glm::vec4(2.0f));
  EXPECT_EQ(component.intensity, 3.5f);
  EXPECT_EQ(component.range, 25.0f);
}

using SceneLoaderCameraTest = SceneLoaderTest;

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateCameraComponentIfCameraFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Camera>(entity));
  EXPECT_FALSE(entityDatabase.has<liquid::PerspectiveLens>(entity));
  EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatio>(entity));
}

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateCameraComponentIfCameraFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::Camera>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::DirectionalLight>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatio>(entity));
  }
}

TEST_F(SceneLoaderCameraTest,
       TriesToFillAllPossibleValuesIfCameraFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  liquid::PerspectiveLens defaults{};

  float validFov = 65.0f;
  float validNear = 0.5f;
  float validFar = 1000.0f;
  float validAspectRatio = 2.0f;

  // FOV
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"]["fov"] = invalidNode;
    node["components"]["camera"]["near"] = validNear;
    node["components"]["camera"]["far"] = validFar;
    node["components"]["camera"]["aspectRatio"] = validAspectRatio;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<liquid::PerspectiveLens>(entity);

    EXPECT_EQ(component.fovY, defaults.fovY);
    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
  }

  // Near
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"]["fov"] = validFov;
    node["components"]["camera"]["near"] = invalidNode;
    node["components"]["camera"]["far"] = validFar;
    node["components"]["camera"]["aspectRatio"] = validAspectRatio;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<liquid::PerspectiveLens>(entity);

    EXPECT_EQ(component.fovY, validFov);
    EXPECT_EQ(component.near, defaults.near);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
  }

  // Far
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"]["fov"] = validFov;
    node["components"]["camera"]["near"] = validNear;
    node["components"]["camera"]["far"] = invalidNode;
    node["components"]["camera"]["aspectRatio"] = validAspectRatio;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<liquid::PerspectiveLens>(entity);

    EXPECT_EQ(component.fovY, validFov);
    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, defaults.far);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
  }

  // Aspect ratio
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["camera"]["fov"] = validFov;
    node["components"]["camera"]["near"] = validNear;
    node["components"]["camera"]["far"] = validFar;
    node["components"]["camera"]["aspectRatio"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::PerspectiveLens>(entity));
    EXPECT_TRUE(entityDatabase.has<liquid::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<liquid::PerspectiveLens>(entity);

    EXPECT_EQ(component.fovY, validFov);
    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, defaults.aspectRatio);
  }
}

TEST_F(SceneLoaderCameraTest, CreatesCameraComponentWithDefaultValues) {
  liquid::Camera defaults{};
  auto [node, entity] = createNode();
  node["components"]["camera"]["fov"] = 20.0f;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Camera>(entity));
  const auto &component = entityDatabase.get<liquid::Camera>(entity);

  EXPECT_EQ(component.projectionMatrix, defaults.projectionMatrix);
  EXPECT_EQ(component.viewMatrix, defaults.viewMatrix);
  EXPECT_EQ(component.projectionViewMatrix, defaults.projectionViewMatrix);
}

TEST_F(SceneLoaderCameraTest,
       CreatesAutoAspectRatioComponentIfAspectRatioIsAuto) {
  auto [node, entity] = createNode();
  node["components"]["camera"]["aspectRatio"] = "auto";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_TRUE(entityDatabase.has<liquid::AutoAspectRatio>(entity));
}

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateAutoAspectRatioComponentIfAspectRatioIsFixed) {
  auto [node, entity] = createNode();
  node["components"]["camera"]["aspectRatio"] = 2.0f;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::AutoAspectRatio>(entity));
}

TEST_F(SceneLoaderCameraTest, CreatesCameraComponentWithFileDataIfValidField) {
  float validFov = 65.0f;
  float validNear = 0.5f;
  float validFar = 1000.0f;
  float validAspectRatio = 2.0f;

  auto [node, entity] = createNode();
  node["components"]["camera"]["fov"] = validFov;
  node["components"]["camera"]["near"] = validNear;
  node["components"]["camera"]["far"] = validFar;
  node["components"]["camera"]["aspectRatio"] = validAspectRatio;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  const auto &lens = entityDatabase.get<liquid::PerspectiveLens>(entity);

  EXPECT_EQ(lens.fovY, validFov);
  EXPECT_EQ(lens.near, validNear);
  EXPECT_EQ(lens.far, validFar);
  EXPECT_EQ(lens.aspectRatio, validAspectRatio);
}

using SceneLoaderAudioTest = SceneLoaderTest;

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfAudioFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::AudioSource>(entity));
}

TEST_F(SceneLoaderAudioTest, DoesNotCreateAudioComponentIfAudioFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["audio"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfAudioSourceFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["audio"]["source"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfNoAudioHandleInRegistry) {
  liquid::AssetData<liquid::AudioAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getAudios().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["audio"]["source"] = "hello.lqmesh";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::AudioSource>(entity));
}

TEST_F(SceneLoaderAudioTest, CreatesAudioComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::AudioAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lqmesh";
  auto handle = assetRegistry.getAudios().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["audio"]["source"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::AudioSource>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::AudioSource>(entity).source, handle);
}

using SceneLoaderScriptTest = SceneLoaderTest;

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfScriptFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Script>(entity));
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfScriptFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["script"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::Script>(entity));
  }
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfNoScriptHandleInRegistry) {
  liquid::AssetData<liquid::LuaScriptAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lua";
  auto handle = assetRegistry.getLuaScripts().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["script"] = "hello.lua";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Script>(entity));
}

TEST_F(SceneLoaderScriptTest, CreatesScriptComponentWithFileDataIfValidField) {
  liquid::AssetData<liquid::LuaScriptAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.lua";
  auto handle = assetRegistry.getLuaScripts().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["script"] = data.relativePath.string();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Script>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::Script>(entity).handle, handle);
}

using SceneLoaderTextTest = SceneLoaderTest;

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::Text>(entity));
}

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["text"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFontIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["text"]["font"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::Text>(entity));
  }
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateTextComponentIfNoFontHandleInRegistry) {
  liquid::AssetData<liquid::FontAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.ttf";
  auto handle = assetRegistry.getFonts().addAsset(data);

  auto [node, entity] = createNode();
  node["components"]["text"]["font"] = "hello.ttf";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Text>(entity));
}

TEST_F(SceneLoaderScriptTest,
       TriesToFillTextComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  liquid::AssetData<liquid::FontAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.ttf";
  auto handle = assetRegistry.getFonts().addAsset(data);

  liquid::Text defaults{};

  auto validContent = "Hello world";
  auto validLineHeight = 20.0f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["text"]["lineHeight"] = invalidNode;
    node["components"]["text"]["content"] = validContent;
    node["components"]["text"]["font"] = data.relativePath.string();

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::Text>(entity));
    const auto &text = entityDatabase.get<liquid::Text>(entity);

    EXPECT_EQ(text.text, validContent);
    EXPECT_EQ(text.lineHeight, defaults.lineHeight);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["text"]["lineHeight"] = validLineHeight;
    node["components"]["text"]["content"] = invalidNode;
    node["components"]["text"]["font"] = data.relativePath.string();

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::Text>(entity));
    const auto &text = entityDatabase.get<liquid::Text>(entity);

    EXPECT_EQ(text.text, defaults.text);
    EXPECT_EQ(text.lineHeight, validLineHeight);
  }
}

TEST_F(SceneLoaderTextTest, CreatesTextComponentWithFileDataIfValidField) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  liquid::AssetData<liquid::FontAsset> data{};
  data.relativePath = liquid::Path("test") / "hello.ttf";
  auto handle = assetRegistry.getFonts().addAsset(data);

  liquid::Text defaults{};

  auto validContent = "Hello world";
  auto validLineHeight = 20.0f;

  auto [node, entity] = createNode();
  node["components"]["text"]["lineHeight"] = validLineHeight;
  node["components"]["text"]["content"] = validContent;
  node["components"]["text"]["font"] = data.relativePath.string();

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Text>(entity));
  const auto &text = entityDatabase.get<liquid::Text>(entity);

  EXPECT_EQ(text.text, validContent);
  EXPECT_EQ(text.lineHeight, validLineHeight);
  EXPECT_EQ(text.font, handle);
}

using SceneLoaderRigidBodyTest = SceneLoaderTest;

TEST_F(SceneLoaderRigidBodyTest,
       DoesNotCreateRigidBodyComponentIfRigidBodyFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::RigidBody>(entity));
}

TEST_F(SceneLoaderRigidBodyTest,
       DoesNotCreateRigidBodyComponentIfRigidBodyFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["rigidBody"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderRigidBodyTest,
       TriesToFillRigidBodyComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  liquid::RigidBody defaultComponent{};
  auto defaults = defaultComponent.dynamicDesc;

  auto validMass = 2.5f;
  auto validInertia = glm::vec3(2.5f);
  auto validGravity = true;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["rigidBody"]["mass"] = invalidNode;
    node["components"]["rigidBody"]["inertia"] = validInertia;
    node["components"]["rigidBody"]["gravity"] = validGravity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::RigidBody>(entity));
    const auto &rigidBody =
        entityDatabase.get<liquid::RigidBody>(entity).dynamicDesc;

    EXPECT_EQ(rigidBody.mass, defaults.mass);
    EXPECT_EQ(rigidBody.inertia, validInertia);
    EXPECT_EQ(rigidBody.applyGravity, validGravity);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["rigidBody"]["mass"] = validMass;
    node["components"]["rigidBody"]["inertia"] = invalidNode;
    node["components"]["rigidBody"]["gravity"] = validGravity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::RigidBody>(entity));
    const auto &rigidBody =
        entityDatabase.get<liquid::RigidBody>(entity).dynamicDesc;

    EXPECT_EQ(rigidBody.mass, validMass);
    EXPECT_EQ(rigidBody.inertia, defaults.inertia);
    EXPECT_EQ(rigidBody.applyGravity, validGravity);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["rigidBody"]["mass"] = validMass;
    node["components"]["rigidBody"]["inertia"] = validInertia;
    node["components"]["rigidBody"]["gravity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_TRUE(entityDatabase.has<liquid::RigidBody>(entity));
    const auto &rigidBody =
        entityDatabase.get<liquid::RigidBody>(entity).dynamicDesc;

    EXPECT_EQ(rigidBody.mass, validMass);
    EXPECT_EQ(rigidBody.inertia, validInertia);
    EXPECT_EQ(rigidBody.applyGravity, defaults.applyGravity);
  }
}

TEST_F(SceneLoaderRigidBodyTest,
       CreatesRigidBodyComponentWithFileDataIfValidField) {
  auto validMass = 2.5f;
  auto validInertia = glm::vec3(2.5f);
  auto validGravity = true;

  auto [node, entity] = createNode();
  node["components"]["rigidBody"]["mass"] = validMass;
  node["components"]["rigidBody"]["inertia"] = validInertia;
  node["components"]["rigidBody"]["applyGravity"] = validGravity;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::RigidBody>(entity));
  const auto &rigidBody =
      entityDatabase.get<liquid::RigidBody>(entity).dynamicDesc;

  EXPECT_EQ(rigidBody.mass, validMass);
  EXPECT_EQ(rigidBody.inertia, validInertia);
  EXPECT_EQ(rigidBody.applyGravity, validGravity);
}

using SceneLoaderCollidableTest = SceneLoaderTest;

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<liquid::Collidable>(entity));
}

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableShapeIsUnknown) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  node["components"]["collidable"]["shape"] = "unknown";

  EXPECT_FALSE(entityDatabase.has<liquid::Collidable>(entity));
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableBoxComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = liquid::PhysicsGeometryBox{};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"]["shape"] = "box";
    node["components"]["collidable"]["halfExtents"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
    const auto &collidable = std::get<liquid::PhysicsGeometryBox>(
        entityDatabase.get<liquid::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.halfExtents, defaults.halfExtents);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesBoxCollidableWithFileDataIfValidField) {
  auto validHalfExtents = glm::vec3(2.5f);

  auto [node, entity] = createNode();
  node["components"]["collidable"]["shape"] = "box";
  node["components"]["collidable"]["halfExtents"] = validHalfExtents;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
  const auto &collidable = std::get<liquid::PhysicsGeometryBox>(
      entityDatabase.get<liquid::Collidable>(entity).geometryDesc.params);

  EXPECT_EQ(collidable.halfExtents, validHalfExtents);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableSphereComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = liquid::PhysicsGeometrySphere{};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"]["shape"] = "sphere";
    node["components"]["collidable"]["radius"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
    const auto &collidable = std::get<liquid::PhysicsGeometrySphere>(
        entityDatabase.get<liquid::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.radius, defaults.radius);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesSphereCollidableWithFileDataIfValidField) {
  auto validRadius = 2.5f;

  auto [node, entity] = createNode();
  node["components"]["collidable"]["shape"] = "sphere";
  node["components"]["collidable"]["radius"] = validRadius;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
  const auto &collidable = std::get<liquid::PhysicsGeometrySphere>(
      entityDatabase.get<liquid::Collidable>(entity).geometryDesc.params);

  EXPECT_EQ(collidable.radius, validRadius);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableCapsuleComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = liquid::PhysicsGeometryCapsule{};

  auto validHalfHeight = 3.5f;
  auto validRadius = 2.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"]["shape"] = "capsule";
    node["components"]["collidable"]["radius"] = invalidNode;
    node["components"]["collidable"]["halfHeight"] = validHalfHeight;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
    const auto &collidable = std::get<liquid::PhysicsGeometryCapsule>(
        entityDatabase.get<liquid::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.radius, defaults.radius);
    EXPECT_EQ(collidable.halfHeight, validHalfHeight);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["collidable"]["shape"] = "capsule";
    node["components"]["collidable"]["radius"] = validRadius;
    node["components"]["collidable"]["halfHeight"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
    const auto &collidable = std::get<liquid::PhysicsGeometryCapsule>(
        entityDatabase.get<liquid::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.radius, validRadius);
    EXPECT_EQ(collidable.halfHeight, defaults.halfHeight);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesCapsuleCollidableWithFileDataIfValidField) {
  auto validHalfHeight = 3.5f;
  auto validRadius = 2.5f;

  auto [node, entity] = createNode();
  node["components"]["collidable"]["shape"] = "capsule";
  node["components"]["collidable"]["radius"] = validRadius;
  node["components"]["collidable"]["halfHeight"] = validHalfHeight;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
  const auto &collidable = std::get<liquid::PhysicsGeometryCapsule>(
      entityDatabase.get<liquid::Collidable>(entity).geometryDesc.params);

  EXPECT_EQ(collidable.radius, validRadius);
  EXPECT_EQ(collidable.halfHeight, validHalfHeight);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableComponentMaterialsIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = liquid::PhysicsMaterialDesc{};

  auto validDynamicFriction = 3.5f;
  auto validRestitution = 2.5f;
  auto validStaticFriction = 1.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["components"]["collidable"]["shape"] = "box";
    node["components"]["collidable"]["dynamicFriction"] = invalidNode;
    node["components"]["collidable"]["restitution"] = validRestitution;
    node["components"]["collidable"]["staticFriction"] = validStaticFriction;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
    const auto &material =
        entityDatabase.get<liquid::Collidable>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, defaults.dynamicFriction);
    EXPECT_EQ(material.restitution, validRestitution);
    EXPECT_EQ(material.staticFriction, validStaticFriction);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["components"]["collidable"]["shape"] = "sphere";
    node["components"]["collidable"]["dynamicFriction"] = validDynamicFriction;
    node["components"]["collidable"]["restitution"] = invalidNode;
    node["components"]["collidable"]["staticFriction"] = validStaticFriction;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
    const auto &material =
        entityDatabase.get<liquid::Collidable>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
    EXPECT_EQ(material.restitution, defaults.restitution);
    EXPECT_EQ(material.staticFriction, validStaticFriction);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["components"]["collidable"]["shape"] = "capsule";
    node["components"]["collidable"]["dynamicFriction"] = validDynamicFriction;
    node["components"]["collidable"]["restitution"] = validRestitution;
    node["components"]["collidable"]["staticFriction"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
    const auto &material =
        entityDatabase.get<liquid::Collidable>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
    EXPECT_EQ(material.restitution, validRestitution);
    EXPECT_EQ(material.staticFriction, defaults.staticFriction);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesCollidableMaterialsWithFileDataIfValidField) {
  auto validDynamicFriction = 3.5f;
  auto validRestitution = 2.5f;
  auto validStaticFriction = 1.5f;

  auto [node, entity] = createNode();
  // Shape does not matter here
  node["components"]["collidable"]["shape"] = "plane";
  node["components"]["collidable"]["dynamicFriction"] = validDynamicFriction;
  node["components"]["collidable"]["restitution"] = validRestitution;
  node["components"]["collidable"]["staticFriction"] = validStaticFriction;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Collidable>(entity));
  const auto &material =
      entityDatabase.get<liquid::Collidable>(entity).materialDesc;

  EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
  EXPECT_EQ(material.restitution, validRestitution);
  EXPECT_EQ(material.staticFriction, validStaticFriction);
}

using SceneLoaderParentTest = SceneLoaderTest;

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentFieldDoesNotExist) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Parent>(entity));
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["components"]["transform"]["parent"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<liquid::Parent>(entity));
  }
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentDoesNotExist) {
  static constexpr uint64_t NonExistentId = 255;
  auto [parentNode, parentEntity] = createNode();

  auto [node, entity] = createNode();
  node["components"]["transform"]["parent"] = NonExistentId;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Parent>(entity));
  EXPECT_FALSE(entityDatabase.has<liquid::Children>(parentEntity));
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentIsNotCreatedWithSceneLoader) {
  static constexpr uint64_t ParentId = 255;

  auto parentEntity = entityDatabase.create();
  entityDatabase.set<liquid::Id>(parentEntity, {ParentId});

  auto [node, entity] = createNode();
  node["components"]["transform"]["parent"] = ParentId;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<liquid::Parent>(entity));
  EXPECT_FALSE(entityDatabase.has<liquid::Children>(parentEntity));
}

TEST_F(SceneLoaderParentTest, CreatesParentComponentIfParentEntityExists) {
  auto [parentNode, parentEntity] = createNode();

  auto [node, entity] = createNode();
  node["components"]["transform"]["parent"] = parentNode["id"];
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Parent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::Parent>(entity).parent, parentEntity);
  EXPECT_TRUE(entityDatabase.has<liquid::Children>(parentEntity));
  EXPECT_EQ(entityDatabase.get<liquid::Children>(parentEntity).children.at(0),
            entity);
}

TEST_F(SceneLoaderParentTest,
       AddsChildToParentComponentIfChildrenComponentAlreadyExists) {
  auto [parentNode, parentEntity] = createNode();
  entityDatabase.set<liquid::Children>(parentEntity, {{liquid::Entity::Null}});

  auto [node, entity] = createNode();
  node["components"]["transform"]["parent"] = parentNode["id"];
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<liquid::Parent>(entity));
  EXPECT_EQ(entityDatabase.get<liquid::Parent>(entity).parent, parentEntity);
  EXPECT_TRUE(entityDatabase.has<liquid::Children>(parentEntity));
  EXPECT_EQ(entityDatabase.get<liquid::Children>(parentEntity).children.at(1),
            entity);
}

using SceneLoaderActiveCameraTest = SceneLoaderTest;

TEST_F(
    SceneLoaderActiveCameraTest,
    ReturnsLastFoundCameraEntityInTheDatabaseIfStartingCameraInSceneNodeIsNotScalar) {

  auto camera1 = createNode(true).second;
  entityDatabase.set<liquid::PerspectiveLens>(camera1, {});

  auto camera2 = createNode(true).second;
  entityDatabase.set<liquid::PerspectiveLens>(camera2, {});

  {
    YAML::Node node(YAML::NodeType::Null);

    auto res = sceneLoader.loadStartingCamera(node, entityIdCache,
                                              liquid::Entity::Null);
    EXPECT_TRUE(res.hasData());
    EXPECT_EQ(res.getData(), camera2);
  }

  {
    YAML::Node node(YAML::NodeType::Map);

    auto res = sceneLoader.loadStartingCamera(node, entityIdCache,
                                              liquid::Entity::Null);
    EXPECT_TRUE(res.hasData());
    EXPECT_EQ(res.getData(), camera2);
  }

  {
    YAML::Node node(YAML::NodeType::Sequence);

    auto res = sceneLoader.loadStartingCamera(node, entityIdCache,
                                              liquid::Entity::Null);
    EXPECT_TRUE(res.hasData());
    EXPECT_EQ(res.getData(), camera2);
  }

  {
    YAML::Node node(YAML::NodeType::Undefined);

    auto res = sceneLoader.loadStartingCamera(node, entityIdCache,
                                              liquid::Entity::Null);
    EXPECT_TRUE(res.hasData());
    EXPECT_EQ(res.getData(), camera2);
  }
}

TEST_F(
    SceneLoaderActiveCameraTest,
    ReturnsLastFoundCameraEntityInTheDatabaseIfStartingCameraInSceneNodeDoesNotExistInDatabase) {

  auto camera1 = createNode(true).second;
  entityDatabase.set<liquid::PerspectiveLens>(camera1, {});

  auto camera2 = createNode(true).second;
  entityDatabase.set<liquid::PerspectiveLens>(camera2, {});

  {
    YAML::Node node(23232);

    auto res = sceneLoader.loadStartingCamera(node, entityIdCache,
                                              liquid::Entity::Null);
    EXPECT_TRUE(res.hasData());
    EXPECT_EQ(res.getData(), camera2);
  }
}

TEST_F(
    SceneLoaderActiveCameraTest,
    ReturnsLastFoundCameraEntityInTheDatabaseIfStartingCameraInSceneNodeDoesNotHaveACameraComponent) {
  auto idNode = createNode(true).first;

  auto camera1 = createNode(true).second;
  entityDatabase.set<liquid::PerspectiveLens>(camera1, {});

  auto camera2 = createNode(true).second;
  entityDatabase.set<liquid::PerspectiveLens>(camera2, {});

  {
    auto res = sceneLoader.loadStartingCamera(idNode["id"], entityIdCache,
                                              liquid::Entity::Null);
    EXPECT_TRUE(res.hasData());
    EXPECT_EQ(res.getData(), camera2);
  }
}

TEST_F(SceneLoaderActiveCameraTest,
       ReturnsStartingCameraEntityFromSceneNodeIfEntityHasACameraComponent) {
  auto startingCameraNode = createNode(true);
  entityDatabase.set<liquid::PerspectiveLens>(startingCameraNode.second, {});

  auto camera1 = createNode(true).second;
  entityDatabase.set<liquid::PerspectiveLens>(camera1, {});

  auto camera2 = createNode(true).second;
  entityDatabase.set<liquid::PerspectiveLens>(camera2, {});

  {
    auto res = sceneLoader.loadStartingCamera(
        startingCameraNode.first["id"], entityIdCache, liquid::Entity::Null);
    EXPECT_TRUE(res.hasData());
    EXPECT_EQ(res.getData(), startingCameraNode.second);
  }
}
