#include "quoll/core/Base.h"
#include "quoll/core/Delete.h"
#include "quoll/core/Id.h"
#include "quoll/core/Name.h"
#include "quoll/animation/Animator.h"
#include "quoll/animation/AnimatorEvent.h"
#include "quoll/asset/AssetCache.h"
#include "quoll/audio/AudioSource.h"
#include "quoll/audio/AudioStart.h"
#include "quoll/audio/AudioStatus.h"
#include "quoll/entity/EntityDatabase.h"
#include "quoll/input/InputMap.h"
#include "quoll/io/SceneLoader.h"
#include "quoll/lua-scripting/LuaScript.h"
#include "quoll/physics/Collidable.h"
#include "quoll/physics/Force.h"
#include "quoll/physics/RigidBody.h"
#include "quoll/physics/RigidBodyClear.h"
#include "quoll/physics/Torque.h"
#include "quoll/physx/PhysxInstance.h"
#include "quoll/renderer/Mesh.h"
#include "quoll/renderer/MeshRenderer.h"
#include "quoll/renderer/SkinnedMeshRenderer.h"
#include "quoll/scene/AutoAspectRatio.h"
#include "quoll/scene/Camera.h"
#include "quoll/scene/CascadedShadowMap.h"
#include "quoll/scene/Children.h"
#include "quoll/scene/DirectionalLight.h"
#include "quoll/scene/EnvironmentLighting.h"
#include "quoll/scene/EnvironmentSkybox.h"
#include "quoll/scene/LocalTransform.h"
#include "quoll/scene/Parent.h"
#include "quoll/scene/PerspectiveLens.h"
#include "quoll/scene/PointLight.h"
#include "quoll/scene/Sprite.h"
#include "quoll/scene/WorldTransform.h"
#include "quoll/skeleton/JointAttachment.h"
#include "quoll/skeleton/Skeleton.h"
#include "quoll/text/Text.h"
#include "quoll/ui/UICanvas.h"
#include "quoll/ui/UICanvasRenderRequest.h"
#include "quoll-tests/Testing.h"
#include "quoll-tests/test-utils/AssetCacheUtils.h"

class SceneLoaderTest : public ::testing::Test {
public:
  SceneLoaderTest()
      : sceneLoader(assetCache, entityDatabase), assetCache("/") {}

  std::pair<YAML::Node, quoll::Entity> createNode(bool create = true) {
    auto id = lastId++;

    YAML::Node node;
    node["id"] = id;

    if (create) {
      auto entity = entityDatabase.create();
      entityIdCache.insert_or_assign(id, entity);

      entityDatabase.set<quoll::Id>(entity, {id});

      return {node, entity};
    }

    return {node, quoll::Entity::Null};
  }

  template <typename TAssetData>
  quoll::AssetRef<TAssetData> createAsset(TAssetData data = {}) {
    return createAssetInCache(assetCache, data);
  }

public:
  quoll::AssetCache assetCache;
  quoll::EntityDatabase entityDatabase;
  quoll::detail::EntityIdCache entityIdCache;
  quoll::detail::SceneLoader sceneLoader;

private:
  u32 lastId = 1;
};

using SceneLoaderNameTest = SceneLoaderTest;

TEST_F(SceneLoaderNameTest, CreatesAutoGeneratedNameIfNameFieldIsNotDefined) {
  auto [node, entity] = createNode();
  auto untitledName = "Untitled " + node["id"].as<quoll::String>();

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Name>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Name>(entity).name, untitledName);
}

TEST_F(SceneLoaderNameTest, CreatesAutoGeneratedNameIfNameFieldIsInvalid) {
  auto [node, entity] = createNode();
  auto untitledName = "Untitled " + node["id"].as<quoll::String>();

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Name>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Name>(entity).name, untitledName);
}

TEST_F(SceneLoaderNameTest, CreatesNameComponentWithFileDataIfValidField) {
  auto [node, entity] = createNode();
  node["name"] = "Hello World";

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Name>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Name>(entity).name, "Hello World");
}

using SceneLoaderTransformTest = SceneLoaderTest;

TEST_F(SceneLoaderTransformTest, CreatesIdentityWorldTransform) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::WorldTransform>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::WorldTransform>(entity).worldTransform,
            glm::mat4{1.0f});
}

TEST_F(SceneLoaderTransformTest,
       CreatesEmptyTransformComponentIfTransformFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  quoll::LocalTransform expected{};

  ASSERT_TRUE(entityDatabase.has<quoll::LocalTransform>(entity));

  const auto &actual = entityDatabase.get<quoll::LocalTransform>(entity);

  EXPECT_EQ(actual.localPosition, expected.localPosition);
  EXPECT_EQ(actual.localRotation, expected.localRotation);
  EXPECT_EQ(actual.localScale, expected.localScale);

  EXPECT_EQ(entityDatabase.get<quoll::WorldTransform>(entity).worldTransform,
            glm::mat4{1.0f});
}

TEST_F(SceneLoaderTransformTest,
       TriesToFillAllPossibleValuesIfInvalidStructure) {
  quoll::LocalTransform defaults{};
  glm::vec3 validPosition(2.0f);
  glm::quat validRotation(0.0f, 1.0f, 0.0f, 0.0f);
  glm::vec3 validScale(4.5f);

  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["transform"]["position"] = value;
    node["transform"]["rotation"] = validRotation;
    node["transform"]["scale"] = validScale;

    sceneLoader.loadComponents(node, entity, entityIdCache);
    const auto &transform = entityDatabase.get<quoll::LocalTransform>(entity);

    EXPECT_EQ(transform.localPosition, defaults.localPosition);
    EXPECT_EQ(transform.localRotation, validRotation);
    EXPECT_EQ(transform.localScale, validScale);
  }

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["transform"]["position"] = validPosition;
    node["transform"]["rotation"] = value;
    node["transform"]["scale"] = validScale;

    sceneLoader.loadComponents(node, entity, entityIdCache);
    const auto &transform = entityDatabase.get<quoll::LocalTransform>(entity);

    EXPECT_EQ(transform.localPosition, validPosition);
    EXPECT_EQ(transform.localRotation, defaults.localRotation);
    EXPECT_EQ(transform.localScale, validScale);
  }

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["transform"]["position"] = validPosition;
    node["transform"]["rotation"] = validRotation;
    node["transform"]["scale"] = value;

    sceneLoader.loadComponents(node, entity, entityIdCache);
    const auto &transform = entityDatabase.get<quoll::LocalTransform>(entity);

    EXPECT_EQ(transform.localPosition, validPosition);
    EXPECT_EQ(transform.localRotation, validRotation);
    EXPECT_EQ(transform.localScale, defaults.localScale);
  }
}

TEST_F(SceneLoaderTransformTest,
       CreatesTransformComponentWithFileDataIfValidField) {
  quoll::LocalTransform defaults{};
  glm::vec3 validPosition(2.0f);
  glm::quat validRotation(0.0f, 1.0f, 0.0f, 0.0f);
  glm::vec3 validScale(4.5f);

  auto [node, entity] = createNode();
  node["transform"]["position"] = validPosition;
  node["transform"]["rotation"] = validRotation;
  node["transform"]["scale"] = validScale;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  const auto &transform = entityDatabase.get<quoll::LocalTransform>(entity);
  EXPECT_EQ(transform.localPosition, validPosition);
  EXPECT_EQ(transform.localRotation, validRotation);
  EXPECT_EQ(transform.localScale, validScale);
}

using SceneLoaderSpriteTest = SceneLoaderTest;

TEST_F(SceneLoaderSpriteTest,
       DoesNotCreateSpriteComponentIfSpriteFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Sprite>(entity));
}

TEST_F(SceneLoaderSpriteTest,
       DoesNotCreateSpriteComponentIfSpriteFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["sprite"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::Sprite>(entity));
  }
}

TEST_F(SceneLoaderSpriteTest,
       DoesNotCreateSpriteComponentIfNoTextureAssetInRegistry) {
  auto [node, entity] = createNode();
  node["sprite"] = "hello.ktx2";
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Sprite>(entity));
}

TEST_F(SceneLoaderSpriteTest, CreatesSpriteComponentWithFileDataIfValidField) {
  auto texture = createAsset<quoll::TextureAsset>();

  auto [node, entity] = createNode();
  node["sprite"] = texture.meta().uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Sprite>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Sprite>(entity).texture,
            texture.handle());
}

using SceneLoaderMeshTest = SceneLoaderTest;

TEST_F(SceneLoaderMeshTest, DoesNotCreateMeshComponentIfMeshFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Mesh>(entity));
}

TEST_F(SceneLoaderMeshTest, DoesNotCreateMeshComponentIfMeshFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["mesh"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::Mesh>(entity));
  }
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateMeshComponentIfNoMeshHandleInRegistry) {
  auto [node, entity] = createNode();
  node["mesh"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Mesh>(entity));
}

TEST_F(SceneLoaderMeshTest, CreatesMeshComponentIfValidAssetTypeIsMesh) {
  auto mesh1 = createAsset<quoll::MeshAsset>();

  auto [node, entity] = createNode();
  node["mesh"] = mesh1.meta().uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Mesh>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Mesh>(entity).asset, mesh1.handle());
}

TEST_F(SceneLoaderMeshTest,
       CreatesSkinnedMeshComponentIfValidAssetTypeIsSkinnedMesh) {
  auto mesh1 = createAsset<quoll::MeshAsset>();

  auto [node, entity] = createNode();
  node["mesh"] = mesh1.meta().uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Mesh>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Mesh>(entity).asset, mesh1.handle());
}

using SceneLoaderMeshRendererTest = SceneLoaderTest;

TEST_F(SceneLoaderMeshRendererTest, DoesNotCreateComponentIfFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::MeshRenderer>(entity));
}

TEST_F(SceneLoaderMeshRendererTest, DoesNotCreateComponentIfFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["meshRenderer"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::MeshRenderer>(entity));
  }
}

TEST_F(SceneLoaderMeshRendererTest, CreatesComponentWithMaterialsIfValid) {
  auto material1 = createAsset<quoll::MaterialAsset>();
  auto material2 = createAsset<quoll::MaterialAsset>();

  auto [node, entity] = createNode();
  node["meshRenderer"]["materials"].push_back(material1.meta().uuid);
  node["meshRenderer"]["materials"].push_back(material2.meta().uuid);

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<quoll::MeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::MeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 2);
  EXPECT_EQ(renderer.materials.at(0).handle(), material1.handle());
  EXPECT_EQ(renderer.materials.at(1).handle(), material2.handle());
}

TEST_F(SceneLoaderMeshRendererTest,
       CreatesComponentAndIgnoresInvalidMaterials) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  auto material1 = createAsset<quoll::MaterialAsset>();

  auto [node, entity] = createNode();
  // Valid node
  node["meshRenderer"]["materials"].push_back(material1.meta().uuid);

  // Non-existent node
  node["meshRenderer"]["materials"].push_back("material25");

  // Invalid schema
  for (auto invalidNode : invalidNodes) {
    node["meshRenderer"]["materials"].push_back(invalidNode);
  }

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<quoll::MeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::MeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 1);
  EXPECT_EQ(renderer.materials.at(0).handle(), material1.handle());
}

TEST_F(SceneLoaderMeshRendererTest, CreatesComponentWithNoMaterials) {
  auto [node, entity] = createNode();
  node["meshRenderer"]["materials"] = YAML::Node(YAML::NodeType::Sequence);

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<quoll::MeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::MeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 0);
}

TEST_F(SceneLoaderMeshRendererTest,
       CreatesComponentWithNoMaterialsIfNoMaterialsField) {
  auto [node, entity] = createNode();
  node["meshRenderer"]["materials"] = YAML::Node(YAML::NodeType::Map);

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<quoll::MeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::MeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 0);
}

using SceneLoaderSkinnedMeshRendererTest = SceneLoaderTest;

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       DoesNotCreateComponentIfFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
}

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       DoesNotCreateComponentIfFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skinnedMeshRenderer"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  }
}

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       CreatesComponentWithMaterialsIfValid) {
  auto material1 = createAsset<quoll::MaterialAsset>();
  auto material2 = createAsset<quoll::MaterialAsset>();

  auto [node, entity] = createNode();
  node["skinnedMeshRenderer"]["materials"].push_back(material1.meta().uuid);
  node["skinnedMeshRenderer"]["materials"].push_back(material2.meta().uuid);

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::SkinnedMeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 2);
  EXPECT_EQ(renderer.materials.at(0).handle(), material1.handle());
  EXPECT_EQ(renderer.materials.at(1).handle(), material2.handle());
}

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       CreatesComponentAndIgnoresInvalidMaterials) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  auto material1 = createAsset<quoll::MaterialAsset>();

  auto [node, entity] = createNode();
  // Valid node
  node["skinnedMeshRenderer"]["materials"].push_back(material1.meta().uuid);

  // Non-existent node
  node["skinnedMeshRenderer"]["materials"].push_back("material25");

  // Invalid schema
  for (auto invalidNode : invalidNodes) {
    node["skinnedMeshRenderer"]["materials"].push_back(invalidNode);
  }

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::SkinnedMeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 1);
  EXPECT_EQ(renderer.materials.at(0).handle(), material1.handle());
}

TEST_F(SceneLoaderSkinnedMeshRendererTest, CreatesComponentWithNoMaterials) {
  auto [node, entity] = createNode();
  node["skinnedMeshRenderer"]["materials"] =
      YAML::Node(YAML::NodeType::Sequence);

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::SkinnedMeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 0);
}

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       CreatesComponentWithNoMaterialsIfNoMaterialsField) {
  auto [node, entity] = createNode();
  node["skinnedMeshRenderer"]["materials"] = YAML::Node(YAML::NodeType::Map);

  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::SkinnedMeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 0);
}

using SceneLoaderSkeletonTest = SceneLoaderTest;

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfSkeletonFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::SkeletonAssetRef>(entity));
}

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfSkeletonFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skeleton"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::SkeletonAssetRef>(entity));
  }
}

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfNoSkeletonHandleInRegistry) {
  auto [node, entity] = createNode();
  node["skeleton"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::SkeletonAssetRef>(entity));
}

TEST_F(SceneLoaderSkeletonTest,
       CreatesSkeletonComponentWithFileDataIfValidField) {
  quoll::SkeletonAsset data{};

  static constexpr u32 NumJoints = 5;

  for (u32 i = 0; i < NumJoints; ++i) {
    f32 fi = static_cast<f32>(i);

    data.jointLocalPositions.push_back(glm::vec3(fi));
    data.jointLocalRotations.push_back(glm::quat(fi, fi, fi, fi));
    data.jointLocalScales.push_back(glm::vec3(fi * 5.0f));
    data.jointParents.push_back(i - 1);
    data.jointInverseBindMatrices.push_back(glm::mat4(fi));
    data.jointNames.push_back("J" + std::to_string(i));
  }

  auto asset = createAssetInCache(assetCache, data);

  auto [node, entity] = createNode();
  node["skeleton"] = asset.meta().uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::SkeletonAssetRef>(entity));

  const auto &skeleton = entityDatabase.get<quoll::SkeletonAssetRef>(entity);
  EXPECT_EQ(skeleton.asset, asset.handle());
}

using SceneLoaderJointAttachmentTest = SceneLoaderTest;

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointAttachmentFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::JointAttachment>(entity));
}

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointAttachmentFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["jointAttachment"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::SkeletonAssetRef>(entity));
  }
}

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointFieldIsNotDefined) {
  auto [node, entity] = createNode();
  node["jointAttachment"]["test"] = 10;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::JointAttachment>(entity));
}

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointFieldIsNegative) {
  auto [node, entity] = createNode();
  node["jointAttachment"]["joint"] = -1;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::JointAttachment>(entity));
}

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointFieldIsLargerThanMaximumJointSize) {
  auto [node, entity] = createNode();
  node["jointAttachment"]["joint"] = std::numeric_limits<u8>::max();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::JointAttachment>(entity));
}

TEST_F(SceneLoaderJointAttachmentTest,
       CreatesJointAttachmentWithDefinedJointValue) {
  auto [node, entity] = createNode();
  node["jointAttachment"]["joint"] = 20;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_TRUE(entityDatabase.has<quoll::JointAttachment>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::JointAttachment>(entity).joint, 20);
}

using SceneLoaderAnimatorTest = SceneLoaderTest;

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAnimatorFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::AnimatorAssetRef>(entity));
}

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAnimatorFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["animator"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::AnimatorAssetRef>(entity));
  }
}

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAssetFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node("invalid-node")};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["animator"]["asset"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::AnimatorAssetRef>(entity));
  }
}

TEST_F(SceneLoaderAnimatorTest, CreatesAnimatorComponentIfAllFieldsAreValid) {
  auto animator1 = createAsset<quoll::AnimatorAsset>({.initialState = 5});

  auto [node, entity] = createNode();
  node["animator"]["asset"] = animator1.meta().uuid;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::AnimatorAssetRef>(entity));

  const auto &component = entityDatabase.get<quoll::AnimatorAssetRef>(entity);
  EXPECT_EQ(component.asset, animator1.handle());
}

using SceneLoaderLightTest = SceneLoaderTest;

TEST_F(SceneLoaderLightTest,
       DoesNotCreateLightComponentIfLightFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightTypeIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightTypeIsUndefined) {
  static constexpr u32 InvalidStart = 1;

  // Check for 10 items
  static constexpr u32 Size = 10;

  for (u32 i = InvalidStart; i < InvalidStart + Size; ++i) {
    auto [node, entity] = createNode();
    node["light"]["type"] = i;
    sceneLoader.loadComponents(node, entity, entityIdCache);

    EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       TriesToFillDirectionalComponentValuesIfLightPropertiesAreInvalid) {
  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  quoll::DirectionalLight defaults{};

  glm::vec4 validColor{0.5f};
  f32 validIntensity = 3.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["color"] = invalidNode;
    node["light"]["intensity"] = validIntensity;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));

    const auto &component = entityDatabase.get<quoll::DirectionalLight>(entity);

    EXPECT_EQ(component.color, defaults.color);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.direction, glm::vec3(0.0f));
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["color"] = validColor;
    node["light"]["intensity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));

    const auto &component = entityDatabase.get<quoll::DirectionalLight>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, defaults.intensity);
    EXPECT_EQ(component.direction, glm::vec3(0.0f));
  }
}

TEST_F(SceneLoaderLightTest,
       CreatesDirectionalLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["light"]["type"] = 0;
  node["light"]["color"] = glm::vec4(2.0f);
  node["light"]["intensity"] = 3.5f;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));

  const auto &component = entityDatabase.get<quoll::DirectionalLight>(entity);

  EXPECT_EQ(component.color, glm::vec4(2.0f));
  EXPECT_EQ(component.intensity, 3.5f);
  EXPECT_EQ(component.direction, glm::vec3(0.0f));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateCascadedShadowMapForDirectionalLightIfFieldIsNotDefined) {
  auto [node, entity] = createNode();
  node["light"]["type"] = 0;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::CascadedShadowMap>(entity));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateCascadedShadowMapForDirectionalLightIfShadowFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::CascadedShadowMap>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       TriesToFillCascadedShadowDataIfShadowPropertiesAreInvalid) {
  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["softShadows"] = invalidNode;
    node["light"]["shadow"]["splitLambda"] = 0.5f;
    node["light"]["shadow"]["numCascades"] = 2;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.5f);
    EXPECT_EQ(component.numCascades, 2);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["softShadows"] = false;
    node["light"]["shadow"]["splitLambda"] = invalidNode;
    node["light"]["shadow"]["numCascades"] = 2;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, false);
    EXPECT_EQ(component.splitLambda, 0.8f);
    EXPECT_EQ(component.numCascades, 2);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["softShadows"] = false;
    node["light"]["shadow"]["splitLambda"] = 0.5f;
    node["light"]["shadow"]["numCascades"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, false);
    EXPECT_EQ(component.splitLambda, 0.5f);
    EXPECT_EQ(component.numCascades, 4);
  }

  // Split lambda > 1.0
  {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["splitLambda"] = 1.5f;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 1.0f);
    EXPECT_EQ(component.numCascades, 4);
  }

  // Split lambda < 0.0
  {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["splitLambda"] = -0.5f;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.0f);
    EXPECT_EQ(component.numCascades, 4);
  }

  // Num cascades > 6
  {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["numCascades"] = 10;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.8f);
    EXPECT_EQ(component.numCascades, 6);
  }

  // Num cascades < 1
  {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["numCascades"] = 0;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.8f);
    EXPECT_EQ(component.numCascades, 1);
  }
}

TEST_F(
    SceneLoaderLightTest,
    CreatesCascadedShadowMapForDirectionalLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["light"]["type"] = 0;
  node["light"]["shadow"]["softShadows"] = false;
  node["light"]["shadow"]["splitLambda"] = 0.5f;
  node["light"]["shadow"]["numCascades"] = 2;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
  ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

  const auto &component = entityDatabase.get<quoll::CascadedShadowMap>(entity);

  EXPECT_EQ(component.softShadows, false);
  EXPECT_EQ(component.splitLambda, 0.5f);
  EXPECT_EQ(component.numCascades, 2);
}

TEST_F(
    SceneLoaderLightTest,
    TriesToFillPointLightComponentValuesIfLightPropertiesAreInvalidForPointLightType) {
  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  quoll::PointLight defaults{};

  glm::vec4 validColor{0.5f};
  f32 validIntensity = 3.5f;
  f32 validRange = 25.0f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 1;
    node["light"]["color"] = invalidNode;
    node["light"]["intensity"] = validIntensity;
    node["light"]["range"] = validRange;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PointLight>(entity));

    const auto &component = entityDatabase.get<quoll::PointLight>(entity);

    EXPECT_EQ(component.color, defaults.color);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.range, validRange);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 1;
    node["light"]["color"] = validColor;
    node["light"]["intensity"] = invalidNode;
    node["light"]["range"] = validRange;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PointLight>(entity));

    const auto &component = entityDatabase.get<quoll::PointLight>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, defaults.intensity);
    EXPECT_EQ(component.range, validRange);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 1;
    node["light"]["color"] = validColor;
    node["light"]["intensity"] = validIntensity;
    node["light"]["range"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PointLight>(entity));

    const auto &component = entityDatabase.get<quoll::PointLight>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.range, defaults.range);
  }
}

TEST_F(SceneLoaderLightTest, CreatesPointLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["light"]["type"] = 1;
  node["light"]["color"] = glm::vec4(2.0f);
  node["light"]["intensity"] = 3.5f;
  node["light"]["range"] = 25.0f;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::PointLight>(entity));

  const auto &component = entityDatabase.get<quoll::PointLight>(entity);

  EXPECT_EQ(component.color, glm::vec4(2.0f));
  EXPECT_EQ(component.intensity, 3.5f);
  EXPECT_EQ(component.range, 25.0f);
}

using SceneLoaderCameraTest = SceneLoaderTest;

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateCameraComponentIfCameraFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Camera>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::PerspectiveLens>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));
}

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateCameraComponentIfCameraFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::Camera>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));
  }
}

TEST_F(SceneLoaderCameraTest,
       TriesToFillAllPossibleValuesIfCameraFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  quoll::PerspectiveLens defaults{};

  f32 validNear = 0.5f;
  f32 validFar = 1000.0f;
  f32 validAspectRatio = 2.0f;
  glm::vec2 validSensorSize{50.0f, 45.0f};
  f32 validFocalLength = 100.0f;
  f32 validAperture = 2.5f;
  f32 validShutterSpeed = 0.125f;
  u32 validSensitivity = 2500;

  // Near
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = invalidNode;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, defaults.near);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Far
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = invalidNode;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, defaults.far);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Aspect ratio
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aspectRatio"] = invalidNode;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, defaults.aspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Sensor size
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = invalidNode;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, defaults.sensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Focal length
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = invalidNode;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, defaults.focalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Aperture
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = invalidNode;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, defaults.aperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Shutter speed
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = invalidNode;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, defaults.shutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Sensitivity
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, defaults.sensitivity);
  }
}

TEST_F(SceneLoaderCameraTest,
       CreatesCameraComponentWithDefaultValuesIfValuesAreNegative) {
  quoll::PerspectiveLens defaults{};

  auto [node, entity] = createNode();
  node["camera"]["near"] = -1.0f;
  node["camera"]["far"] = -2.0f;
  node["camera"]["aspectRatio"] = -3.0f;
  node["camera"]["sensorSize"] = glm::vec2(-1.0f, 2.5f);
  node["camera"]["focalLength"] = -2.5f;
  node["camera"]["aperture"] = -2.5f;
  node["camera"]["shutterSpeed"] = -2.5f;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));

  const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

  EXPECT_EQ(component.near, defaults.near);
  EXPECT_EQ(component.far, defaults.far);
  EXPECT_EQ(component.aspectRatio, defaults.aspectRatio);
  EXPECT_EQ(component.sensorSize, defaults.sensorSize);
  EXPECT_EQ(component.focalLength, defaults.focalLength);
  EXPECT_EQ(component.aperture, defaults.aperture);
  EXPECT_EQ(component.shutterSpeed, defaults.shutterSpeed);
}

TEST_F(SceneLoaderCameraTest, CreatesCameraComponentWithDefaultValues) {
  quoll::Camera defaults{};
  auto [node, entity] = createNode();
  node["camera"]["focalLength"] = 20.0f;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Camera>(entity));
  const auto &component = entityDatabase.get<quoll::Camera>(entity);

  EXPECT_EQ(component.projectionMatrix, defaults.projectionMatrix);
  EXPECT_EQ(component.viewMatrix, defaults.viewMatrix);
  EXPECT_EQ(component.projectionViewMatrix, defaults.projectionViewMatrix);
}

TEST_F(SceneLoaderCameraTest,
       CreatesAutoAspectRatioComponentIfAspectRatioIsAuto) {
  auto [node, entity] = createNode();
  node["camera"]["aspectRatio"] = "auto";
  sceneLoader.loadComponents(node, entity, entityIdCache);
  ASSERT_TRUE(entityDatabase.has<quoll::AutoAspectRatio>(entity));
}

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateAutoAspectRatioComponentIfAspectRatioIsFixed) {
  auto [node, entity] = createNode();
  node["camera"]["aspectRatio"] = 2.0f;
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));
}

TEST_F(SceneLoaderCameraTest, CreatesCameraComponentWithFileDataIfValidField) {
  f32 validNear = 0.5f;
  f32 validFar = 1000.0f;
  f32 validAspectRatio = 2.0f;
  glm::vec2 validSensorSize{50.0f, 45.0f};
  f32 validFocalLength = 100.0f;
  f32 validAperture = 2.5f;
  f32 validShutterSpeed = 0.125f;
  u32 validSensitivity = 2500;

  auto [node, entity] = createNode();
  node["camera"]["near"] = validNear;
  node["camera"]["far"] = validFar;
  node["camera"]["aspectRatio"] = validAspectRatio;
  node["camera"]["sensorSize"] = validSensorSize;
  node["camera"]["focalLength"] = validFocalLength;
  node["camera"]["aperture"] = validAperture;
  node["camera"]["shutterSpeed"] = validShutterSpeed;
  node["camera"]["sensitivity"] = validSensitivity;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  const auto &lens = entityDatabase.get<quoll::PerspectiveLens>(entity);

  EXPECT_EQ(lens.near, validNear);
  EXPECT_EQ(lens.far, validFar);
  EXPECT_EQ(lens.aspectRatio, validAspectRatio);
  EXPECT_EQ(lens.sensorSize, validSensorSize);
  EXPECT_EQ(lens.focalLength, validFocalLength);
  EXPECT_EQ(lens.aperture, validAperture);
  EXPECT_EQ(lens.shutterSpeed, validShutterSpeed);
  EXPECT_EQ(lens.sensitivity, validSensitivity);
}

using SceneLoaderAudioTest = SceneLoaderTest;

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfAudioFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
}

TEST_F(SceneLoaderAudioTest, DoesNotCreateAudioComponentIfAudioFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["audio"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfAudioSourceFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["audio"]["source"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfNoAudioHandleInRegistry) {
  auto [node, entity] = createNode();
  node["audio"]["source"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
}

TEST_F(SceneLoaderAudioTest, CreatesAudioComponentWithFileDataIfValidField) {
  auto audio = createAsset<quoll::AudioAsset>();

  auto [node, entity] = createNode();
  node["audio"]["source"] = audio.meta().uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::AudioSource>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::AudioSource>(entity).asset,
            audio.handle());
}

using SceneLoaderScriptTest = SceneLoaderTest;

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfScriptFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::LuaScript>(entity));
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfScriptFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["script"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::LuaScript>(entity));
  }
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfNoScriptHandleInRegistry) {
  auto [node, entity] = createNode();
  node["script"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::LuaScript>(entity));
}

TEST_F(SceneLoaderScriptTest,
       CreatesScriptComponentWithFileDataIfStringFieldWithValidPath) {
  auto script = createAsset<quoll::LuaScriptAsset>();

  auto [node, entity] = createNode();
  node["script"] = script.meta().uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::LuaScript>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::LuaScript>(entity).asset,
            script.handle());
}

TEST_F(SceneLoaderScriptTest,
       CreatesScriptComponentWithFileAndVariablesIfMapWithValidPath) {
  auto script = createAsset<quoll::LuaScriptAsset>();
  auto prefab = createAsset<quoll::PrefabAsset>();
  auto texture = createAsset<quoll::TextureAsset>();

  auto [node, entity] = createNode();
  node["script"]["asset"] = script.meta().uuid;
  node["script"]["variables"]["test_str"]["type"] = "string";
  node["script"]["variables"]["test_str"]["value"] = "Test string";

  node["script"]["variables"]["test_valid_prefab"]["type"] = "prefab";
  node["script"]["variables"]["test_valid_prefab"]["value"] =
      prefab.meta().uuid;
  node["script"]["variables"]["test_invalid_prefab"]["type"] = "prefab";
  node["script"]["variables"]["test_invalid_prefab"]["value"] =
      "unknown-prefab-file.prefab";

  node["script"]["variables"]["test_valid_texture"]["type"] = "texture";
  node["script"]["variables"]["test_valid_texture"]["value"] =
      texture.meta().uuid;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::LuaScript>(entity));
  const auto &component = entityDatabase.get<quoll::LuaScript>(entity);

  EXPECT_EQ(component.asset, script.handle());

  // Invalid prefab and texture are ignored
  EXPECT_FALSE(component.variables.contains("test_invalid_prefab"));
  EXPECT_FALSE(component.variables.contains("test_invalid_texture"));

  EXPECT_EQ(component.variables.at("test_str").get<quoll::String>(),
            "Test string");
  EXPECT_EQ(component.variables.at("test_valid_prefab")
                .get<quoll::AssetRef<quoll::PrefabAsset>>()
                .handle(),
            prefab.handle());

  EXPECT_EQ(component.variables.at("test_valid_texture")
                .get<quoll::AssetRef<quoll::TextureAsset>>()
                .handle(),
            texture.handle());
}

using SceneLoaderTextTest = SceneLoaderTest;

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_FALSE(entityDatabase.has<quoll::Text>(entity));
}

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["text"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFontIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["text"]["font"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::Text>(entity));
  }
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateTextComponentIfNoFontHandleInRegistry) {
  auto [node, entity] = createNode();
  node["text"]["font"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Text>(entity));
}

TEST_F(SceneLoaderScriptTest,
       TriesToFillTextComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto font = createAsset<quoll::FontAsset>();

  quoll::Text defaults{};

  auto validContent = "Hello world";
  auto validLineHeight = 20.0f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["text"]["lineHeight"] = invalidNode;
    node["text"]["content"] = validContent;
    node["text"]["font"] = font.meta().uuid;

    sceneLoader.loadComponents(node, entity, entityIdCache);
    ASSERT_TRUE(entityDatabase.has<quoll::Text>(entity));
    const auto &text = entityDatabase.get<quoll::Text>(entity);

    EXPECT_EQ(text.content, validContent);
    EXPECT_EQ(text.lineHeight, defaults.lineHeight);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["text"]["lineHeight"] = validLineHeight;
    node["text"]["content"] = invalidNode;
    node["text"]["font"] = font.meta().uuid;

    sceneLoader.loadComponents(node, entity, entityIdCache);
    ASSERT_TRUE(entityDatabase.has<quoll::Text>(entity));
    const auto &text = entityDatabase.get<quoll::Text>(entity);

    EXPECT_EQ(text.content, defaults.content);
    EXPECT_EQ(text.lineHeight, validLineHeight);
  }
}

TEST_F(SceneLoaderTextTest, CreatesTextComponentWithFileDataIfValidField) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto font = createAsset<quoll::FontAsset>();

  quoll::Text defaults{};

  auto validContent = "Hello world";
  auto validLineHeight = 20.0f;

  auto [node, entity] = createNode();
  node["text"]["lineHeight"] = validLineHeight;
  node["text"]["content"] = validContent;
  node["text"]["font"] = font.meta().uuid;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Text>(entity));
  const auto &text = entityDatabase.get<quoll::Text>(entity);

  EXPECT_EQ(text.content, validContent);
  EXPECT_EQ(text.lineHeight, validLineHeight);
  EXPECT_EQ(text.font, font.handle());
}

using SceneLoaderRigidBodyTest = SceneLoaderTest;

TEST_F(SceneLoaderRigidBodyTest,
       DoesNotCreateRigidBodyComponentIfRigidBodyFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_FALSE(entityDatabase.has<quoll::RigidBody>(entity));
}

TEST_F(SceneLoaderRigidBodyTest,
       DoesNotCreateRigidBodyComponentIfRigidBodyFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["rigidBody"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderRigidBodyTest,
       TriesToFillDynamicRigidBodyComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       YAML::Node("random-text")};

  quoll::RigidBody defaultComponent{};
  auto defaults = defaultComponent.dynamicDesc;

  auto validMass = 2.5f;
  auto validInertia = glm::vec3(2.5f);
  auto validGravity = true;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["rigidBody"]["type"] = invalidNode;
    node["rigidBody"]["mass"] = validMass;
    node["rigidBody"]["inertia"] = validInertia;
    node["rigidBody"]["gravity"] = validGravity;

    sceneLoader.loadComponents(node, entity, entityIdCache);
    ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
    const auto &rigidBody = entityDatabase.get<quoll::RigidBody>(entity);

    EXPECT_EQ(rigidBody.type, quoll::RigidBodyType::Dynamic);
    EXPECT_EQ(rigidBody.dynamicDesc.mass, validMass);
    EXPECT_EQ(rigidBody.dynamicDesc.inertia, validInertia);
    EXPECT_EQ(rigidBody.dynamicDesc.applyGravity, validGravity);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["rigidBody"]["type"] = "dynamic";
    node["rigidBody"]["mass"] = invalidNode;
    node["rigidBody"]["inertia"] = validInertia;
    node["rigidBody"]["gravity"] = validGravity;

    sceneLoader.loadComponents(node, entity, entityIdCache);
    ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
    const auto &rigidBody = entityDatabase.get<quoll::RigidBody>(entity);

    EXPECT_EQ(rigidBody.type, quoll::RigidBodyType::Dynamic);
    EXPECT_EQ(rigidBody.dynamicDesc.mass, defaults.mass);
    EXPECT_EQ(rigidBody.dynamicDesc.inertia, validInertia);
    EXPECT_EQ(rigidBody.dynamicDesc.applyGravity, validGravity);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["rigidBody"]["type"] = "dynamic";
    node["rigidBody"]["mass"] = validMass;
    node["rigidBody"]["inertia"] = invalidNode;
    node["rigidBody"]["gravity"] = validGravity;

    sceneLoader.loadComponents(node, entity, entityIdCache);
    ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
    const auto &rigidBody = entityDatabase.get<quoll::RigidBody>(entity);

    EXPECT_EQ(rigidBody.type, quoll::RigidBodyType::Dynamic);
    EXPECT_EQ(rigidBody.dynamicDesc.mass, validMass);
    EXPECT_EQ(rigidBody.dynamicDesc.inertia, defaults.inertia);
    EXPECT_EQ(rigidBody.dynamicDesc.applyGravity, validGravity);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["rigidBody"]["type"] = "dynamic";
    node["rigidBody"]["mass"] = validMass;
    node["rigidBody"]["inertia"] = validInertia;
    node["rigidBody"]["gravity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);
    ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
    const auto &rigidBody = entityDatabase.get<quoll::RigidBody>(entity);

    EXPECT_EQ(rigidBody.type, quoll::RigidBodyType::Dynamic);
    EXPECT_EQ(rigidBody.dynamicDesc.mass, validMass);
    EXPECT_EQ(rigidBody.dynamicDesc.inertia, validInertia);
    EXPECT_EQ(rigidBody.dynamicDesc.applyGravity, defaults.applyGravity);
  }
}

TEST_F(SceneLoaderRigidBodyTest,
       CreatesDynamicRigidBodyComponentWithFileDataIfValidField) {
  auto validMass = 2.5f;
  auto validInertia = glm::vec3(2.5f);
  auto validGravity = true;

  auto [node, entity] = createNode();
  node["rigidBody"]["type"] = "dynamic";
  node["rigidBody"]["mass"] = validMass;
  node["rigidBody"]["inertia"] = validInertia;
  node["rigidBody"]["applyGravity"] = validGravity;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
  const auto &rigidBody = entityDatabase.get<quoll::RigidBody>(entity);

  EXPECT_EQ(rigidBody.type, quoll::RigidBodyType::Dynamic);
  EXPECT_EQ(rigidBody.dynamicDesc.mass, validMass);
  EXPECT_EQ(rigidBody.dynamicDesc.inertia, validInertia);
  EXPECT_EQ(rigidBody.dynamicDesc.applyGravity, validGravity);
}

TEST_F(SceneLoaderRigidBodyTest,
       CreatesKinematicRigidBodyComponentWithFileDataIfValidField) {
  auto [node, entity] = createNode();
  node["rigidBody"]["type"] = "kinematic";

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
  const auto &rigidBody = entityDatabase.get<quoll::RigidBody>(entity);

  EXPECT_EQ(rigidBody.type, quoll::RigidBodyType::Kinematic);
}

TEST_F(SceneLoaderRigidBodyTest, IgnoresDynamicRigidBodyDataIfTypeIsKinematic) {
  quoll::RigidBody defaultComponent{};
  auto defaults = defaultComponent.dynamicDesc;

  auto validMass = 2.5f;
  auto validInertia = glm::vec3(2.5f);
  auto validGravity = true;

  auto [node, entity] = createNode();
  node["rigidBody"]["type"] = "kinematic";
  node["rigidBody"]["mass"] = validMass;
  node["rigidBody"]["inertia"] = validInertia;
  node["rigidBody"]["applyGravity"] = validGravity;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
  const auto &rigidBody = entityDatabase.get<quoll::RigidBody>(entity);

  EXPECT_EQ(rigidBody.type, quoll::RigidBodyType::Kinematic);
  EXPECT_EQ(rigidBody.dynamicDesc.mass, defaults.mass);
  EXPECT_EQ(rigidBody.dynamicDesc.inertia, defaults.inertia);
  EXPECT_EQ(rigidBody.dynamicDesc.applyGravity, defaults.applyGravity);
}

using SceneLoaderCollidableTest = SceneLoaderTest;

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_FALSE(entityDatabase.has<quoll::Collidable>(entity));
}

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableShapeIsUnknown) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  node["collidable"]["shape"] = "unknown";

  EXPECT_FALSE(entityDatabase.has<quoll::Collidable>(entity));
}

TEST_F(SceneLoaderCollidableTest,
       SetsCenterToZeroIfCollidableCenterFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "box";
    node["collidable"]["center"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &center =
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.center;

    EXPECT_EQ(center, glm::vec3(0.0f));
  }
}

TEST_F(SceneLoaderCollidableTest, SetsCenterToProvidedCenterFieldIfValid) {
  auto input = glm::vec3{2.5f, 3.5f, 4.5f};

  auto [node, entity] = createNode();
  node["collidable"]["shape"] = "box";
  node["collidable"]["center"] = input;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &center =
      entityDatabase.get<quoll::Collidable>(entity).geometryDesc.center;

  EXPECT_EQ(center, input);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableBoxComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = quoll::PhysicsGeometryBox{};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "box";
    node["collidable"]["halfExtents"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &collidable = std::get<quoll::PhysicsGeometryBox>(
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.halfExtents, defaults.halfExtents);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesBoxCollidableWithFileDataIfValidField) {
  auto validHalfExtents = glm::vec3(2.5f);

  auto [node, entity] = createNode();
  node["collidable"]["shape"] = "box";
  node["collidable"]["halfExtents"] = validHalfExtents;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &collidable = std::get<quoll::PhysicsGeometryBox>(
      entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

  EXPECT_EQ(collidable.halfExtents, validHalfExtents);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableSphereComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = quoll::PhysicsGeometrySphere{};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "sphere";
    node["collidable"]["radius"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &collidable = std::get<quoll::PhysicsGeometrySphere>(
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.radius, defaults.radius);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesSphereCollidableWithFileDataIfValidField) {
  auto validRadius = 2.5f;

  auto [node, entity] = createNode();
  node["collidable"]["shape"] = "sphere";
  node["collidable"]["radius"] = validRadius;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &collidable = std::get<quoll::PhysicsGeometrySphere>(
      entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

  EXPECT_EQ(collidable.radius, validRadius);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableCapsuleComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = quoll::PhysicsGeometryCapsule{};

  auto validHalfHeight = 3.5f;
  auto validRadius = 2.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "capsule";
    node["collidable"]["radius"] = invalidNode;
    node["collidable"]["halfHeight"] = validHalfHeight;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &collidable = std::get<quoll::PhysicsGeometryCapsule>(
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.radius, defaults.radius);
    EXPECT_EQ(collidable.halfHeight, validHalfHeight);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "capsule";
    node["collidable"]["radius"] = validRadius;
    node["collidable"]["halfHeight"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &collidable = std::get<quoll::PhysicsGeometryCapsule>(
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.radius, validRadius);
    EXPECT_EQ(collidable.halfHeight, defaults.halfHeight);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesCapsuleCollidableWithFileDataIfValidField) {
  auto validHalfHeight = 3.5f;
  auto validRadius = 2.5f;

  auto [node, entity] = createNode();
  node["collidable"]["shape"] = "capsule";
  node["collidable"]["radius"] = validRadius;
  node["collidable"]["halfHeight"] = validHalfHeight;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &collidable = std::get<quoll::PhysicsGeometryCapsule>(
      entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

  EXPECT_EQ(collidable.radius, validRadius);
  EXPECT_EQ(collidable.halfHeight, validHalfHeight);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableComponentMaterialsIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = quoll::PhysicsMaterialDesc{};

  auto validDynamicFriction = 3.5f;
  auto validRestitution = 2.5f;
  auto validStaticFriction = 1.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["dynamicFriction"] = invalidNode;
    node["collidable"]["restitution"] = validRestitution;
    node["collidable"]["staticFriction"] = validStaticFriction;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &material =
        entityDatabase.get<quoll::Collidable>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, defaults.dynamicFriction);
    EXPECT_EQ(material.restitution, validRestitution);
    EXPECT_EQ(material.staticFriction, validStaticFriction);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "sphere";
    node["collidable"]["dynamicFriction"] = validDynamicFriction;
    node["collidable"]["restitution"] = invalidNode;
    node["collidable"]["staticFriction"] = validStaticFriction;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &material =
        entityDatabase.get<quoll::Collidable>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
    EXPECT_EQ(material.restitution, defaults.restitution);
    EXPECT_EQ(material.staticFriction, validStaticFriction);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "capsule";
    node["collidable"]["dynamicFriction"] = validDynamicFriction;
    node["collidable"]["restitution"] = validRestitution;
    node["collidable"]["staticFriction"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &material =
        entityDatabase.get<quoll::Collidable>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
    EXPECT_EQ(material.restitution, validRestitution);
    EXPECT_EQ(material.staticFriction, defaults.staticFriction);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesCollidableMaterialsWithFileDataIfValidField) {
  auto validDynamicFriction = 3.5f;
  auto validRestitution = 2.5f;
  auto validStaticFriction = 1.5f;

  auto [node, entity] = createNode();
  // Shape does not matter here
  node["collidable"]["shape"] = "plane";
  node["collidable"]["dynamicFriction"] = validDynamicFriction;
  node["collidable"]["restitution"] = validRestitution;
  node["collidable"]["staticFriction"] = validStaticFriction;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &material =
      entityDatabase.get<quoll::Collidable>(entity).materialDesc;

  EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
  EXPECT_EQ(material.restitution, validRestitution);
  EXPECT_EQ(material.staticFriction, validStaticFriction);
}

TEST_F(SceneLoaderCollidableTest, SetsCollidableModesToTrueIfInvalidField) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = invalidNode;
    node["collidable"]["useInQueries"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }
}

TEST_F(SceneLoaderCollidableTest, SetsCollidableModesToDataInFileIfValid) {
  {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = false;
    node["collidable"]["useInQueries"] = false;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_FALSE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_FALSE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }

  {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = true;
    node["collidable"]["useInQueries"] = false;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_FALSE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }

  {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = false;
    node["collidable"]["useInQueries"] = true;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_FALSE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }

  {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = true;
    node["collidable"]["useInQueries"] = true;

    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }
}

using SceneLoaderParentTest = SceneLoaderTest;

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentFieldDoesNotExist) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Parent>(entity));
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["transform"]["parent"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::Parent>(entity));
  }
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentDoesNotExist) {
  static constexpr u64 NonExistentId = 255;
  auto [parentNode, parentEntity] = createNode();

  auto [node, entity] = createNode();
  node["transform"]["parent"] = NonExistentId;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Parent>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::Children>(parentEntity));
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentIsNotCreatedWithSceneLoader) {
  static constexpr u64 ParentId = 255;

  auto parentEntity = entityDatabase.create();
  entityDatabase.set<quoll::Id>(parentEntity, {ParentId});

  auto [node, entity] = createNode();
  node["transform"]["parent"] = ParentId;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Parent>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::Children>(parentEntity));
}

TEST_F(SceneLoaderParentTest, CreatesParentComponentIfParentEntityExists) {
  auto [parentNode, parentEntity] = createNode();

  auto [node, entity] = createNode();
  node["transform"]["parent"] = parentNode["id"];
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Parent>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Parent>(entity).parent, parentEntity);
  ASSERT_TRUE(entityDatabase.has<quoll::Children>(parentEntity));
  EXPECT_EQ(entityDatabase.get<quoll::Children>(parentEntity).children.at(0),
            entity);
}

TEST_F(SceneLoaderParentTest,
       AddsChildToParentComponentIfChildrenComponentAlreadyExists) {
  auto [parentNode, parentEntity] = createNode();
  entityDatabase.set<quoll::Children>(parentEntity, {{quoll::Entity::Null}});

  auto [node, entity] = createNode();
  node["transform"]["parent"] = parentNode["id"];
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Parent>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Parent>(entity).parent, parentEntity);
  ASSERT_TRUE(entityDatabase.has<quoll::Children>(parentEntity));
  EXPECT_EQ(entityDatabase.get<quoll::Children>(parentEntity).children.at(1),
            entity);
}

using SceneLoaderActiveCameraTest = SceneLoaderTest;

TEST_F(SceneLoaderActiveCameraTest, ReturnsErrorIfStartingCameraIsNotAnId) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  for (auto node : invalidNodes) {
    auto res = sceneLoader.loadStartingCamera(node, entityIdCache);
    EXPECT_FALSE(res);
  }
}

TEST_F(SceneLoaderActiveCameraTest, ReturnsErrorIfStartingCameraDoesNotExist) {
  YAML::Node node(23232);

  auto res = sceneLoader.loadStartingCamera(node, entityIdCache);
  EXPECT_FALSE(res);
}

TEST_F(SceneLoaderActiveCameraTest,
       ReturnsErrorIfStartingCameraDoesNotHaveCameraComponent) {
  auto idNode = createNode(true).first;

  auto res = sceneLoader.loadStartingCamera(idNode["id"], entityIdCache);
  EXPECT_FALSE(res);
}

TEST_F(SceneLoaderActiveCameraTest,
       ReturnsEntityIfStartingEntityExistsAndHasACamera) {
  auto startingCameraNode = createNode(true);
  entityDatabase.set<quoll::PerspectiveLens>(startingCameraNode.second, {});

  auto camera1 = createNode(true).second;
  entityDatabase.set<quoll::PerspectiveLens>(camera1, {});

  auto camera2 = createNode(true).second;
  entityDatabase.set<quoll::PerspectiveLens>(camera2, {});

  auto res = sceneLoader.loadStartingCamera(startingCameraNode.first["id"],
                                            entityIdCache);
  EXPECT_TRUE(res);
  EXPECT_EQ(res, startingCameraNode.second);
}

using SceneLoaderSkyboxTest = SceneLoaderTest;

TEST_F(SceneLoaderSkyboxTest, DoesNotAddSkyboxIfNoSkyboxField) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
}

TEST_F(SceneLoaderSkyboxTest, DoesNotAddSkyboxComponentIfSkyboxFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skybox"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  }
}

TEST_F(SceneLoaderSkyboxTest,
       DoesNotAddSkyboxComponentIfSkyboxTypeIsNotColorOrTexture) {
  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       YAML::Node("randomType")};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skybox"]["type"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  }
}

TEST_F(SceneLoaderSkyboxTest,
       DoesNotAddSkyboxComponentIfSkyboxTypeIsTextureButTextureIsNotDefined) {
  auto [node, entity] = createNode();
  node["skybox"]["type"] = "texture";
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
}

TEST_F(SceneLoaderSkyboxTest,
       DoesNotAddSkyboxComponentIfSkyboxTypeIsTextureButTextureIsInvalid) {
  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       YAML::Node("randomUuid")};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skybox"]["type"] = "texture";
    node["skybox"]["texture"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  }
}

TEST_F(SceneLoaderSkyboxTest,
       AddsTextureSkyboxIfTypeIsTextureAndTextureExists) {
  auto environment = createAsset<quoll::EnvironmentAsset>();

  auto [node, entity] = createNode();
  node["skybox"]["type"] = "texture";
  node["skybox"]["texture"] = environment.meta().uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache);
  ASSERT_TRUE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  const auto &component = entityDatabase.get<quoll::EnvironmentSkybox>(entity);
  EXPECT_EQ(component.type, quoll::EnvironmentSkyboxType::Texture);
  EXPECT_EQ(component.texture, environment.handle());
}

TEST_F(SceneLoaderSkyboxTest,
       AddsColorSkyboxWithBlackColorIfTypeIsColorButColorIsNotDefined) {
  auto [node, entity] = createNode();
  node["skybox"]["type"] = "color";
  sceneLoader.loadComponents(node, entity, entityIdCache);
  ASSERT_TRUE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));

  const auto &component = entityDatabase.get<quoll::EnvironmentSkybox>(entity);
  EXPECT_EQ(component.type, quoll::EnvironmentSkyboxType::Color);
  EXPECT_EQ(component.color, glm::vec4(0.0f, 0.0f, 0.0f, 1.0f));
}

TEST_F(SceneLoaderSkyboxTest,
       AddsColorSkyboxWithBlackColorIfTypeIsColorButColorIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skybox"]["type"] = "color";
    node["skybox"]["color"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    ASSERT_TRUE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));

    const auto &component =
        entityDatabase.get<quoll::EnvironmentSkybox>(entity);
    EXPECT_EQ(component.type, quoll::EnvironmentSkyboxType::Color);
    EXPECT_EQ(component.color, glm::vec4(0.0f, 0.0f, 0.0f, 1.0f));
  }
}

TEST_F(SceneLoaderSkyboxTest, AddsColorSkyboxIfTypeIsColorAndColorIsDefined) {
  auto [node, entity] = createNode();
  node["skybox"]["type"] = "color";
  node["skybox"]["color"] = glm::vec4(0.4f, 0.2f, 0.5f, 0.2f);
  sceneLoader.loadComponents(node, entity, entityIdCache);
  ASSERT_TRUE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  const auto &component = entityDatabase.get<quoll::EnvironmentSkybox>(entity);
  EXPECT_EQ(component.type, quoll::EnvironmentSkyboxType::Color);
  EXPECT_EQ(component.color, glm::vec4(0.4f, 0.2f, 0.5f, 0.2f));
}

using SceneLoaderEnvironmentLightingTest = SceneLoaderTest;

TEST_F(SceneLoaderEnvironmentLightingTest,
       DoesNotAddEnvironmentLightingIfNoEnvironmentLightingField) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(
      entityDatabase.has<quoll::EnvironmentLightingSkyboxSource>(entity));
}

TEST_F(SceneLoaderEnvironmentLightingTest,
       DoesNotAddEnvironmentLightingIfFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["environmentLighting"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(
        entityDatabase.has<quoll::EnvironmentLightingSkyboxSource>(entity));
  }
}

TEST_F(SceneLoaderEnvironmentLightingTest,
       DoesNotAddEnvironmentLightingIfSourceIsInvalid) {
  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       YAML::Node("randomSource")};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["environmentLighting"]["source"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(
        entityDatabase.has<quoll::EnvironmentLightingSkyboxSource>(entity));
  }
}

TEST_F(SceneLoaderEnvironmentLightingTest,
       AddsSkyboxEnvironmentLightingSourceIfSourceIsSkybox) {
  auto [node, entity] = createNode();
  node["environmentLighting"]["source"] = "skybox";
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_TRUE(
      entityDatabase.has<quoll::EnvironmentLightingSkyboxSource>(entity));
}

using SceneLoaderActiveEnvironmentTest = SceneLoaderTest;

TEST_F(SceneLoaderActiveEnvironmentTest, ReturnsErrorIfEnvironmentIsNotId) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  for (auto node : invalidNodes) {
    auto res = sceneLoader.loadEnvironment(node, entityIdCache);
    EXPECT_FALSE(res);
  }
}

TEST_F(SceneLoaderActiveEnvironmentTest,
       ReturnsErrorIfEnvironmentEntityDoesNotExist) {
  YAML::Node node(23232);

  auto res = sceneLoader.loadEnvironment(node, entityIdCache);
  EXPECT_FALSE(res);
}

TEST_F(SceneLoaderActiveCameraTest, ReturnsEntityIfEnvironmentEntityExists) {
  auto environmentNode = createNode(true);

  auto res =
      sceneLoader.loadEnvironment(environmentNode.first["id"], entityIdCache);
  EXPECT_TRUE(res);
  EXPECT_EQ(res, environmentNode.second);
}

using SceneLoaderInputMapTest = SceneLoaderTest;

TEST_F(SceneLoaderInputMapTest,
       DoesNotCreateInputMapComponentIfInputMapFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
}

TEST_F(SceneLoaderInputMapTest,
       DoesNotCreateInputMapComponentIfInputMapFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["inputMap"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
  }
}

TEST_F(SceneLoaderInputMapTest,
       DoesNotCreateInputMapComponentIfInputMapAssetFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["inputMap"]["asset"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
  }
}

TEST_F(SceneLoaderInputMapTest,
       DoesNotCreateInputMapComponentIfNoInputMapHandleInRegistry) {
  auto [node, entity] = createNode();
  node["inputMap"]["asset"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
}

TEST_F(SceneLoaderInputMapTest, CreatesInputMapComponentIfInputMapAssetExists) {
  auto inputMap = createAsset<quoll::InputMapAsset>();

  auto [node, entity] = createNode();
  node["inputMap"]["asset"] = inputMap.meta().uuid;
  node["inputMap"]["defaultScheme"] = 1;
  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::InputMapAssetRef>(entity).asset,
            inputMap.handle());
  EXPECT_EQ(entityDatabase.get<quoll::InputMapAssetRef>(entity).defaultScheme,
            1);
}

TEST_F(SceneLoaderInputMapTest, SetsInputMapDefaultSchemeToZeroIfInvalidField) {
  auto inputMap = createAsset<quoll::InputMapAsset>();

  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Scalar)};

  for (auto invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["inputMap"]["asset"] = inputMap.meta().uuid;
    node["inputMap"]["defaultScheme"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);

    ASSERT_TRUE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
    EXPECT_EQ(entityDatabase.get<quoll::InputMapAssetRef>(entity).defaultScheme,
              0);
  }
}

using SceneLoaderUICanvasTest = SceneLoaderTest;

TEST_F(SceneLoaderUICanvasTest, DoesNotAddUICanvasComponentIfNoUICanvasField) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_FALSE(entityDatabase.has<quoll::UICanvas>(entity));
}

TEST_F(SceneLoaderUICanvasTest,
       DoesNotAddUICanvasComponentIfUICanvasFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (auto invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["uiCanvas"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);

    EXPECT_FALSE(entityDatabase.has<quoll::UICanvas>(entity));
  }
}

TEST_F(SceneLoaderUICanvasTest,
       CreatesUICanvasComponentIfUICanvasFieldExistsAndIsAnObject) {
  auto [node, entity] = createNode();
  node["uiCanvas"] = YAML::Node(YAML::NodeType::Map);
  sceneLoader.loadComponents(node, entity, entityIdCache);
  EXPECT_TRUE(entityDatabase.has<quoll::UICanvas>(entity));
}
