#include "quoll/core/Base.h"
#include "quoll-tests/Testing.h"

#include "quoll/scripting/Script.h"
#include "quoll/entity/EntityDatabase.h"
#include "quoll/scene/private/SceneLoader.h"

class SceneLoaderTest : public ::testing::Test {
public:
  SceneLoaderTest() : sceneLoader(assetRegistry, entityDatabase) {}

  std::pair<YAML::Node, quoll::Entity> createNode(bool create = true) {
    auto id = lastId++;

    YAML::Node node;
    node["id"] = id;

    if (create) {
      auto entity = entityDatabase.create();
      entityIdCache.insert_or_assign(id, entity);

      entityDatabase.set<quoll::Id>(entity, {id});

      return {node, entity};
    }

    return {node, quoll::Entity::Null};
  }

public:
  quoll::AssetRegistry assetRegistry;
  quoll::EntityDatabase entityDatabase;
  quoll::detail::EntityIdCache entityIdCache;
  quoll::detail::SceneLoader sceneLoader;

private:
  uint32_t lastId = 1;
};

using SceneLoaderNameTest = SceneLoaderTest;

TEST_F(SceneLoaderNameTest, CreatesAutoGeneratedNameIfNameFieldIsNotDefined) {
  auto [node, entity] = createNode();
  auto untitledName = "Untitled " + node["id"].as<quoll::String>();

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Name>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Name>(entity).name, untitledName);
}

TEST_F(SceneLoaderNameTest, CreatesAutoGeneratedNameIfNameFieldIsInvalid) {
  auto [node, entity] = createNode();
  auto untitledName = "Untitled " + node["id"].as<quoll::String>();

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Name>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Name>(entity).name, untitledName);
}

TEST_F(SceneLoaderNameTest, CreatesNameComponentWithFileDataIfValidField) {
  auto [node, entity] = createNode();
  node["name"] = "Hello World";

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Name>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Name>(entity).name, "Hello World");
}

using SceneLoaderTransformTest = SceneLoaderTest;

TEST_F(SceneLoaderTransformTest, CreatesIdentityWorldTransform) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::WorldTransform>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::WorldTransform>(entity).worldTransform,
            glm::mat4{1.0f});
}

TEST_F(SceneLoaderTransformTest,
       CreatesEmptyTransformComponentIfTransformFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  quoll::LocalTransform expected{};

  ASSERT_TRUE(entityDatabase.has<quoll::LocalTransform>(entity));

  const auto &actual = entityDatabase.get<quoll::LocalTransform>(entity);

  EXPECT_EQ(actual.localPosition, expected.localPosition);
  EXPECT_EQ(actual.localRotation, expected.localRotation);
  EXPECT_EQ(actual.localScale, expected.localScale);

  EXPECT_EQ(entityDatabase.get<quoll::WorldTransform>(entity).worldTransform,
            glm::mat4{1.0f});
}

TEST_F(SceneLoaderTransformTest,
       TriesToFillAllPossibleValuesIfInvalidStructure) {
  quoll::LocalTransform defaults{};
  glm::vec3 validPosition(2.0f);
  glm::quat validRotation(0.0f, 1.0f, 0.0f, 0.0f);
  glm::vec3 validScale(4.5f);

  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["transform"]["position"] = value;
    node["transform"]["rotation"] = validRotation;
    node["transform"]["scale"] = validScale;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    const auto &transform = entityDatabase.get<quoll::LocalTransform>(entity);

    EXPECT_EQ(transform.localPosition, defaults.localPosition);
    EXPECT_EQ(transform.localRotation, validRotation);
    EXPECT_EQ(transform.localScale, validScale);
  }

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["transform"]["position"] = validPosition;
    node["transform"]["rotation"] = value;
    node["transform"]["scale"] = validScale;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    const auto &transform = entityDatabase.get<quoll::LocalTransform>(entity);

    EXPECT_EQ(transform.localPosition, validPosition);
    EXPECT_EQ(transform.localRotation, defaults.localRotation);
    EXPECT_EQ(transform.localScale, validScale);
  }

  for (const auto &value : invalidNodes) {
    auto [node, entity] = createNode();
    node["transform"]["position"] = validPosition;
    node["transform"]["rotation"] = validRotation;
    node["transform"]["scale"] = value;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    const auto &transform = entityDatabase.get<quoll::LocalTransform>(entity);

    EXPECT_EQ(transform.localPosition, validPosition);
    EXPECT_EQ(transform.localRotation, validRotation);
    EXPECT_EQ(transform.localScale, defaults.localScale);
  }
}

TEST_F(SceneLoaderTransformTest,
       CreatesTransformComponentWithFileDataIfValidField) {
  quoll::LocalTransform defaults{};
  glm::vec3 validPosition(2.0f);
  glm::quat validRotation(0.0f, 1.0f, 0.0f, 0.0f);
  glm::vec3 validScale(4.5f);

  auto [node, entity] = createNode();
  node["transform"]["position"] = validPosition;
  node["transform"]["rotation"] = validRotation;
  node["transform"]["scale"] = validScale;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  const auto &transform = entityDatabase.get<quoll::LocalTransform>(entity);
  EXPECT_EQ(transform.localPosition, validPosition);
  EXPECT_EQ(transform.localRotation, validRotation);
  EXPECT_EQ(transform.localScale, validScale);
}

using SceneLoaderSpriteTest = SceneLoaderTest;

TEST_F(SceneLoaderSpriteTest,
       DoesNotCreateSpriteComponentIfSpriteFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Sprite>(entity));
}

TEST_F(SceneLoaderSpriteTest,
       DoesNotCreateSpriteComponentIfSpriteFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["sprite"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::Sprite>(entity));
  }
}

TEST_F(SceneLoaderSpriteTest,
       DoesNotCreateSpriteComponentIfNoTextureAssetInRegistry) {
  auto [node, entity] = createNode();
  node["sprite"] = "hello.ktx2";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Sprite>(entity));
}

TEST_F(SceneLoaderSpriteTest, CreatesSpriteComponentWithFileDataIfValidField) {
  quoll::AssetData<quoll::TextureAsset> data{};
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getTextures().addAsset(data);

  auto [node, entity] = createNode();
  node["sprite"] = data.uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Sprite>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Sprite>(entity).handle, handle);
}

using SceneLoaderMeshTest = SceneLoaderTest;

TEST_F(SceneLoaderMeshTest, DoesNotCreateMeshComponentIfMeshFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Mesh>(entity));
}

TEST_F(SceneLoaderMeshTest, DoesNotCreateMeshComponentIfMeshFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["mesh"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::Mesh>(entity));
  }
}

TEST_F(SceneLoaderMeshTest,
       DoesNotCreateMeshComponentIfNoMeshHandleInRegistry) {
  quoll::AssetData<quoll::MeshAsset> data{};
  data.uuid = quoll::Uuid("hello");
  data.type = quoll::AssetType::Mesh;
  auto handle = assetRegistry.getMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["mesh"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Mesh>(entity));
}

TEST_F(SceneLoaderMeshTest, CreatesMeshComponentIfValidAssetTypeIsMesh) {
  quoll::AssetData<quoll::MeshAsset> data{};
  data.type = quoll::AssetType::Mesh;
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["mesh"] = data.uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Mesh>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::SkinnedMesh>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Mesh>(entity).handle, handle);
}

TEST_F(SceneLoaderMeshTest,
       CreatesSkinnedMeshComponentIfValidAssetTypeIsSkinnedMesh) {
  quoll::AssetData<quoll::MeshAsset> data{};
  data.type = quoll::AssetType::SkinnedMesh;
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getMeshes().addAsset(data);

  auto [node, entity] = createNode();
  node["mesh"] = data.uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::SkinnedMesh>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::Mesh>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::SkinnedMesh>(entity).handle, handle);
}

using SceneLoaderMeshRendererTest = SceneLoaderTest;

TEST_F(SceneLoaderMeshRendererTest, DoesNotCreateComponentIfFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::MeshRenderer>(entity));
}

TEST_F(SceneLoaderMeshRendererTest, DoesNotCreateComponentIfFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["meshRenderer"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::MeshRenderer>(entity));
  }
}

TEST_F(SceneLoaderMeshRendererTest, CreatesComponentWithMaterialsIfValid) {
  quoll::AssetData<quoll::MaterialAsset> material1{};
  material1.uuid = quoll::Uuid("material1");
  auto handle1 = assetRegistry.getMaterials().addAsset(material1);

  quoll::AssetData<quoll::MaterialAsset> material2{};
  material2.uuid = quoll::Uuid("material2");
  auto handle2 = assetRegistry.getMaterials().addAsset(material2);

  auto [node, entity] = createNode();
  node["meshRenderer"]["materials"].push_back("material1");
  node["meshRenderer"]["materials"].push_back("material2");

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<quoll::MeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::MeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 2);
  EXPECT_EQ(renderer.materials.at(0), handle1);
  EXPECT_EQ(renderer.materials.at(1), handle2);
}

TEST_F(SceneLoaderMeshRendererTest,
       CreatesComponentAndIgnoresInvalidMaterials) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  quoll::AssetData<quoll::MaterialAsset> material1{};
  material1.uuid = quoll::Uuid("material1");
  auto handle1 = assetRegistry.getMaterials().addAsset(material1);

  auto [node, entity] = createNode();
  // Valid node
  node["meshRenderer"]["materials"].push_back("material1");

  // Non-existent node
  node["meshRenderer"]["materials"].push_back("material25");

  // Invalid schema
  for (auto invalidNode : invalidNodes) {
    node["meshRenderer"]["materials"].push_back(invalidNode);
  }

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<quoll::MeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::MeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 1);
  EXPECT_EQ(renderer.materials.at(0), handle1);
}

TEST_F(SceneLoaderMeshRendererTest, CreatesComponentWithNoMaterials) {
  auto [node, entity] = createNode();
  node["meshRenderer"]["materials"] = YAML::Node(YAML::NodeType::Sequence);

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<quoll::MeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::MeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 0);
}

TEST_F(SceneLoaderMeshRendererTest,
       CreatesComponentWithNoMaterialsIfNoMaterialsField) {
  auto [node, entity] = createNode();
  node["meshRenderer"]["materials"] = YAML::Node(YAML::NodeType::Map);

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<quoll::MeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::MeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 0);
}

using SceneLoaderSkinnedMeshRendererTest = SceneLoaderTest;

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       DoesNotCreateComponentIfFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
}

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       DoesNotCreateComponentIfFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skinnedMeshRenderer"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  }
}

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       CreatesComponentWithMaterialsIfValid) {
  quoll::AssetData<quoll::MaterialAsset> material1{};
  material1.uuid = quoll::Uuid("material1");
  auto handle1 = assetRegistry.getMaterials().addAsset(material1);

  quoll::AssetData<quoll::MaterialAsset> material2{};
  material2.uuid = quoll::Uuid("material2");
  auto handle2 = assetRegistry.getMaterials().addAsset(material2);

  auto [node, entity] = createNode();
  node["skinnedMeshRenderer"]["materials"].push_back("material1");
  node["skinnedMeshRenderer"]["materials"].push_back("material2");

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::SkinnedMeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 2);
  EXPECT_EQ(renderer.materials.at(0), handle1);
  EXPECT_EQ(renderer.materials.at(1), handle2);
}

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       CreatesComponentAndIgnoresInvalidMaterials) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  quoll::AssetData<quoll::MaterialAsset> material1{};
  material1.uuid = quoll::Uuid("material1");
  auto handle1 = assetRegistry.getMaterials().addAsset(material1);

  auto [node, entity] = createNode();
  // Valid node
  node["skinnedMeshRenderer"]["materials"].push_back("material1");

  // Non-existent node
  node["skinnedMeshRenderer"]["materials"].push_back("material25");

  // Invalid schema
  for (auto invalidNode : invalidNodes) {
    node["skinnedMeshRenderer"]["materials"].push_back(invalidNode);
  }

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::SkinnedMeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 1);
  EXPECT_EQ(renderer.materials.at(0), handle1);
}

TEST_F(SceneLoaderSkinnedMeshRendererTest, CreatesComponentWithNoMaterials) {
  auto [node, entity] = createNode();
  node["skinnedMeshRenderer"]["materials"] =
      YAML::Node(YAML::NodeType::Sequence);

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::SkinnedMeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 0);
}

TEST_F(SceneLoaderSkinnedMeshRendererTest,
       CreatesComponentWithNoMaterialsIfNoMaterialsField) {
  auto [node, entity] = createNode();
  node["skinnedMeshRenderer"]["materials"] = YAML::Node(YAML::NodeType::Map);

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<quoll::SkinnedMeshRenderer>(entity));
  const auto &renderer = entityDatabase.get<quoll::SkinnedMeshRenderer>(entity);
  EXPECT_EQ(renderer.materials.size(), 0);
}

using SceneLoaderSkeletonTest = SceneLoaderTest;

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfSkeletonFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Skeleton>(entity));
}

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfSkeletonFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skeleton"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::Skeleton>(entity));
  }
}

TEST_F(SceneLoaderSkeletonTest,
       DoesNotCreateSkeletonComponentIfNoSkeletonHandleInRegistry) {
  quoll::AssetData<quoll::SkeletonAsset> data{};
  data.uuid = quoll::Uuid("hello");

  auto handle = assetRegistry.getSkeletons().addAsset(data);

  auto [node, entity] = createNode();
  node["skeleton"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Skeleton>(entity));
}

TEST_F(SceneLoaderSkeletonTest,
       CreatesSkeletonComponentWithFileDataIfValidField) {
  quoll::AssetData<quoll::SkeletonAsset> data{};

  static constexpr uint32_t NumJoints = 5;

  for (uint32_t i = 0; i < NumJoints; ++i) {
    float fi = static_cast<float>(i);

    data.data.jointLocalPositions.push_back(glm::vec3(fi));
    data.data.jointLocalRotations.push_back(glm::quat(fi, fi, fi, fi));
    data.data.jointLocalScales.push_back(glm::vec3(fi * 5.0f));
    data.data.jointParents.push_back(i - 1);
    data.data.jointInverseBindMatrices.push_back(glm::mat4(fi));
    data.data.jointNames.push_back("J" + std::to_string(i));
  }

  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getSkeletons().addAsset(data);

  auto [node, entity] = createNode();
  node["skeleton"] = data.uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Skeleton>(entity));

  const auto &skeleton = entityDatabase.get<quoll::Skeleton>(entity);
  EXPECT_EQ(skeleton.assetHandle, handle);

  EXPECT_EQ(skeleton.numJoints, NumJoints);
  for (uint32_t i = 0; i < NumJoints; ++i) {
    float fi = static_cast<float>(i);

    EXPECT_EQ(skeleton.jointLocalPositions.at(i),
              data.data.jointLocalPositions.at(i));
    EXPECT_EQ(skeleton.jointLocalRotations.at(i),
              data.data.jointLocalRotations.at(i));
    EXPECT_EQ(skeleton.jointLocalScales.at(i),
              data.data.jointLocalScales.at(i));
    EXPECT_EQ(skeleton.jointParents.at(i), data.data.jointParents.at(i));
    EXPECT_EQ(skeleton.jointInverseBindMatrices.at(i),
              data.data.jointInverseBindMatrices.at(i));
    EXPECT_EQ(skeleton.jointNames.at(i), data.data.jointNames.at(i));

    EXPECT_EQ(skeleton.jointFinalTransforms.at(i), glm::mat4{1.0f});
    EXPECT_EQ(skeleton.jointWorldTransforms.at(i), glm::mat4{1.0f});
  }
}

using SceneLoaderJointAttachmentTest = SceneLoaderTest;

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointAttachmentFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::JointAttachment>(entity));
}

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointAttachmentFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["jointAttachment"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::Skeleton>(entity));
  }
}

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointFieldIsNotDefined) {
  auto [node, entity] = createNode();
  node["jointAttachment"]["test"] = 10;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::JointAttachment>(entity));
}

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointFieldIsNegative) {
  auto [node, entity] = createNode();
  node["jointAttachment"]["joint"] = -1;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::JointAttachment>(entity));
}

TEST_F(SceneLoaderJointAttachmentTest,
       DoesNotCreateJointAttachmentIfJointFieldIsLargerThanMaximumJointSize) {
  auto [node, entity] = createNode();
  node["jointAttachment"]["joint"] = std::numeric_limits<uint8_t>::max();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::JointAttachment>(entity));
}

TEST_F(SceneLoaderJointAttachmentTest,
       CreatesJointAttachmentWithDefinedJointValue) {
  auto [node, entity] = createNode();
  node["jointAttachment"]["joint"] = 20;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_TRUE(entityDatabase.has<quoll::JointAttachment>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::JointAttachment>(entity).joint, 20);
}

using SceneLoaderAnimatorTest = SceneLoaderTest;

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAnimatorFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache);

  EXPECT_FALSE(entityDatabase.has<quoll::Animator>(entity));
}

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAnimatorFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["animator"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::Animator>(entity));
  }
}

TEST_F(SceneLoaderAnimatorTest,
       DoesNotCreateAnimatorComponentIfAssetFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node("invalid-node")};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["animator"]["asset"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache);
    EXPECT_FALSE(entityDatabase.has<quoll::Animator>(entity));
  }
}

TEST_F(SceneLoaderAnimatorTest, CreatesAnimatorComponentIfAllFieldsAreValid) {
  quoll::AssetData<quoll::AnimatorAsset> data{};
  data.uuid = quoll::Uuid("hello");
  data.data.initialState = 5;
  auto handle = assetRegistry.getAnimators().addAsset(data);

  auto [node, entity] = createNode();
  node["animator"]["asset"] = data.uuid;

  sceneLoader.loadComponents(node, entity, entityIdCache);

  ASSERT_TRUE(entityDatabase.has<quoll::Animator>(entity));

  const auto &animator = entityDatabase.get<quoll::Animator>(entity);
  EXPECT_EQ(animator.asset, handle);
  EXPECT_EQ(animator.currentState, std::numeric_limits<size_t>::max());
  EXPECT_EQ(animator.normalizedTime, 0.0f);
}

using SceneLoaderLightTest = SceneLoaderTest;

TEST_F(SceneLoaderLightTest,
       DoesNotCreateLightComponentIfLightFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightTypeIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateAnyLightComponentIfLightTypeIsUndefined) {
  static constexpr uint32_t InvalidStart = 1;

  // Check for 10 items
  static constexpr uint32_t Size = 10;

  for (uint32_t i = InvalidStart; i < InvalidStart + Size; ++i) {
    auto [node, entity] = createNode();
    node["light"]["type"] = i;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       TriesToFillDirectionalComponentValuesIfLightPropertiesAreInvalid) {
  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  quoll::DirectionalLight defaults{};

  glm::vec4 validColor{0.5f};
  float validIntensity = 3.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["color"] = invalidNode;
    node["light"]["intensity"] = validIntensity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));

    const auto &component = entityDatabase.get<quoll::DirectionalLight>(entity);

    EXPECT_EQ(component.color, defaults.color);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.direction, glm::vec3(0.0f));
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["color"] = validColor;
    node["light"]["intensity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));

    const auto &component = entityDatabase.get<quoll::DirectionalLight>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, defaults.intensity);
    EXPECT_EQ(component.direction, glm::vec3(0.0f));
  }
}

TEST_F(SceneLoaderLightTest,
       CreatesDirectionalLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["light"]["type"] = 0;
  node["light"]["color"] = glm::vec4(2.0f);
  node["light"]["intensity"] = 3.5f;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));

  const auto &component = entityDatabase.get<quoll::DirectionalLight>(entity);

  EXPECT_EQ(component.color, glm::vec4(2.0f));
  EXPECT_EQ(component.intensity, 3.5f);
  EXPECT_EQ(component.direction, glm::vec3(0.0f));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateCascadedShadowMapForDirectionalLightIfFieldIsNotDefined) {
  auto [node, entity] = createNode();
  node["light"]["type"] = 0;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::CascadedShadowMap>(entity));
}

TEST_F(SceneLoaderLightTest,
       DoesNotCreateCascadedShadowMapForDirectionalLightIfShadowFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::CascadedShadowMap>(entity));
  }
}

TEST_F(SceneLoaderLightTest,
       TriesToFillCascadedShadowDataIfShadowPropertiesAreInvalid) {
  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["softShadows"] = invalidNode;
    node["light"]["shadow"]["splitLambda"] = 0.5f;
    node["light"]["shadow"]["numCascades"] = 2;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.5f);
    EXPECT_EQ(component.numCascades, 2);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["softShadows"] = false;
    node["light"]["shadow"]["splitLambda"] = invalidNode;
    node["light"]["shadow"]["numCascades"] = 2;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, false);
    EXPECT_EQ(component.splitLambda, 0.8f);
    EXPECT_EQ(component.numCascades, 2);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["softShadows"] = false;
    node["light"]["shadow"]["splitLambda"] = 0.5f;
    node["light"]["shadow"]["numCascades"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, false);
    EXPECT_EQ(component.splitLambda, 0.5f);
    EXPECT_EQ(component.numCascades, 4);
  }

  // Split lambda > 1.0
  {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["splitLambda"] = 1.5f;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 1.0f);
    EXPECT_EQ(component.numCascades, 4);
  }

  // Split lambda < 0.0
  {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["splitLambda"] = -0.5f;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.0f);
    EXPECT_EQ(component.numCascades, 4);
  }

  // Num cascades > 6
  {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["numCascades"] = 10;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.8f);
    EXPECT_EQ(component.numCascades, 6);
  }

  // Num cascades < 1
  {
    auto [node, entity] = createNode();
    node["light"]["type"] = 0;
    node["light"]["shadow"]["numCascades"] = 0;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

    const auto &component =
        entityDatabase.get<quoll::CascadedShadowMap>(entity);

    EXPECT_EQ(component.softShadows, true);
    EXPECT_EQ(component.splitLambda, 0.8f);
    EXPECT_EQ(component.numCascades, 1);
  }
}

TEST_F(
    SceneLoaderLightTest,
    CreatesCascadedShadowMapForDirectionalLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["light"]["type"] = 0;
  node["light"]["shadow"]["softShadows"] = false;
  node["light"]["shadow"]["splitLambda"] = 0.5f;
  node["light"]["shadow"]["numCascades"] = 2;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::DirectionalLight>(entity));
  ASSERT_TRUE(entityDatabase.has<quoll::CascadedShadowMap>(entity));

  const auto &component = entityDatabase.get<quoll::CascadedShadowMap>(entity);

  EXPECT_EQ(component.softShadows, false);
  EXPECT_EQ(component.splitLambda, 0.5f);
  EXPECT_EQ(component.numCascades, 2);
}

TEST_F(
    SceneLoaderLightTest,
    TriesToFillPointLightComponentValuesIfLightPropertiesAreInvalidForPointLightType) {
  YAML::Node invalidArray(YAML::NodeType::Sequence);
  invalidArray.push_back("Test 1");
  invalidArray.push_back("Test 2");
  invalidArray.push_back(15.0f);
  invalidArray.push_back(20.0f);

  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       invalidArray};

  quoll::PointLight defaults{};

  glm::vec4 validColor{0.5f};
  float validIntensity = 3.5f;
  float validRange = 25.0f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 1;
    node["light"]["color"] = invalidNode;
    node["light"]["intensity"] = validIntensity;
    node["light"]["range"] = validRange;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PointLight>(entity));

    const auto &component = entityDatabase.get<quoll::PointLight>(entity);

    EXPECT_EQ(component.color, defaults.color);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.range, validRange);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 1;
    node["light"]["color"] = validColor;
    node["light"]["intensity"] = invalidNode;
    node["light"]["range"] = validRange;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PointLight>(entity));

    const auto &component = entityDatabase.get<quoll::PointLight>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, defaults.intensity);
    EXPECT_EQ(component.range, validRange);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["light"]["type"] = 1;
    node["light"]["color"] = validColor;
    node["light"]["intensity"] = validIntensity;
    node["light"]["range"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PointLight>(entity));

    const auto &component = entityDatabase.get<quoll::PointLight>(entity);

    EXPECT_EQ(component.color, validColor);
    EXPECT_EQ(component.intensity, validIntensity);
    EXPECT_EQ(component.range, defaults.range);
  }
}

TEST_F(SceneLoaderLightTest, CreatesPointLightWithFileDataIfValidProperties) {
  auto [node, entity] = createNode();
  node["light"]["type"] = 1;
  node["light"]["color"] = glm::vec4(2.0f);
  node["light"]["intensity"] = 3.5f;
  node["light"]["range"] = 25.0f;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::PointLight>(entity));

  const auto &component = entityDatabase.get<quoll::PointLight>(entity);

  EXPECT_EQ(component.color, glm::vec4(2.0f));
  EXPECT_EQ(component.intensity, 3.5f);
  EXPECT_EQ(component.range, 25.0f);
}

using SceneLoaderCameraTest = SceneLoaderTest;

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateCameraComponentIfCameraFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Camera>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::PerspectiveLens>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));
}

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateCameraComponentIfCameraFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::Camera>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::DirectionalLight>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));
  }
}

TEST_F(SceneLoaderCameraTest,
       TriesToFillAllPossibleValuesIfCameraFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  quoll::PerspectiveLens defaults{};

  float validNear = 0.5f;
  float validFar = 1000.0f;
  float validAspectRatio = 2.0f;
  glm::vec2 validSensorSize{50.0f, 45.0f};
  float validFocalLength = 100.0f;
  float validAperture = 2.5f;
  float validShutterSpeed = 0.125f;
  uint32_t validSensitivity = 2500;

  // Near
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = invalidNode;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, defaults.near);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Far
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = invalidNode;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, defaults.far);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Aspect ratio
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aspectRatio"] = invalidNode;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    ASSERT_TRUE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, defaults.aspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Sensor size
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = invalidNode;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, defaults.sensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Focal length
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = invalidNode;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, defaults.focalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Aperture
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = invalidNode;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, defaults.aperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Shutter speed
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = invalidNode;
    node["camera"]["sensitivity"] = validSensitivity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, defaults.shutterSpeed);
    EXPECT_EQ(component.sensitivity, validSensitivity);
  }

  // Sensitivity
  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["camera"]["near"] = validNear;
    node["camera"]["far"] = validFar;
    node["camera"]["aspectRatio"] = validAspectRatio;
    node["camera"]["sensorSize"] = validSensorSize;
    node["camera"]["focalLength"] = validFocalLength;
    node["camera"]["aperture"] = validAperture;
    node["camera"]["shutterSpeed"] = validShutterSpeed;
    node["camera"]["sensitivity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));
    EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));

    const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

    EXPECT_EQ(component.near, validNear);
    EXPECT_EQ(component.far, validFar);
    EXPECT_EQ(component.aspectRatio, validAspectRatio);
    EXPECT_EQ(component.sensorSize, validSensorSize);
    EXPECT_EQ(component.focalLength, validFocalLength);
    EXPECT_EQ(component.aperture, validAperture);
    EXPECT_EQ(component.shutterSpeed, validShutterSpeed);
    EXPECT_EQ(component.sensitivity, defaults.sensitivity);
  }
}

TEST_F(SceneLoaderCameraTest,
       CreatesCameraComponentWithDefaultValuesIfValuesAreNegative) {
  quoll::PerspectiveLens defaults{};

  auto [node, entity] = createNode();
  node["camera"]["near"] = -1.0f;
  node["camera"]["far"] = -2.0f;
  node["camera"]["aspectRatio"] = -3.0f;
  node["camera"]["sensorSize"] = glm::vec2(-1.0f, 2.5f);
  node["camera"]["focalLength"] = -2.5f;
  node["camera"]["aperture"] = -2.5f;
  node["camera"]["shutterSpeed"] = -2.5f;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::PerspectiveLens>(entity));

  const auto &component = entityDatabase.get<quoll::PerspectiveLens>(entity);

  EXPECT_EQ(component.near, defaults.near);
  EXPECT_EQ(component.far, defaults.far);
  EXPECT_EQ(component.aspectRatio, defaults.aspectRatio);
  EXPECT_EQ(component.sensorSize, defaults.sensorSize);
  EXPECT_EQ(component.focalLength, defaults.focalLength);
  EXPECT_EQ(component.aperture, defaults.aperture);
  EXPECT_EQ(component.shutterSpeed, defaults.shutterSpeed);
}

TEST_F(SceneLoaderCameraTest, CreatesCameraComponentWithDefaultValues) {
  quoll::Camera defaults{};
  auto [node, entity] = createNode();
  node["camera"]["focalLength"] = 20.0f;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Camera>(entity));
  const auto &component = entityDatabase.get<quoll::Camera>(entity);

  EXPECT_EQ(component.projectionMatrix, defaults.projectionMatrix);
  EXPECT_EQ(component.viewMatrix, defaults.viewMatrix);
  EXPECT_EQ(component.projectionViewMatrix, defaults.projectionViewMatrix);
}

TEST_F(SceneLoaderCameraTest,
       CreatesAutoAspectRatioComponentIfAspectRatioIsAuto) {
  auto [node, entity] = createNode();
  node["camera"]["aspectRatio"] = "auto";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  ASSERT_TRUE(entityDatabase.has<quoll::AutoAspectRatio>(entity));
}

TEST_F(SceneLoaderCameraTest,
       DoesNotCreateAutoAspectRatioComponentIfAspectRatioIsFixed) {
  auto [node, entity] = createNode();
  node["camera"]["aspectRatio"] = 2.0f;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<quoll::AutoAspectRatio>(entity));
}

TEST_F(SceneLoaderCameraTest, CreatesCameraComponentWithFileDataIfValidField) {
  float validNear = 0.5f;
  float validFar = 1000.0f;
  float validAspectRatio = 2.0f;
  glm::vec2 validSensorSize{50.0f, 45.0f};
  float validFocalLength = 100.0f;
  float validAperture = 2.5f;
  float validShutterSpeed = 0.125f;
  uint32_t validSensitivity = 2500;

  auto [node, entity] = createNode();
  node["camera"]["near"] = validNear;
  node["camera"]["far"] = validFar;
  node["camera"]["aspectRatio"] = validAspectRatio;
  node["camera"]["sensorSize"] = validSensorSize;
  node["camera"]["focalLength"] = validFocalLength;
  node["camera"]["aperture"] = validAperture;
  node["camera"]["shutterSpeed"] = validShutterSpeed;
  node["camera"]["sensitivity"] = validSensitivity;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  const auto &lens = entityDatabase.get<quoll::PerspectiveLens>(entity);

  EXPECT_EQ(lens.near, validNear);
  EXPECT_EQ(lens.far, validFar);
  EXPECT_EQ(lens.aspectRatio, validAspectRatio);
  EXPECT_EQ(lens.sensorSize, validSensorSize);
  EXPECT_EQ(lens.focalLength, validFocalLength);
  EXPECT_EQ(lens.aperture, validAperture);
  EXPECT_EQ(lens.shutterSpeed, validShutterSpeed);
  EXPECT_EQ(lens.sensitivity, validSensitivity);
}

using SceneLoaderAudioTest = SceneLoaderTest;

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfAudioFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
}

TEST_F(SceneLoaderAudioTest, DoesNotCreateAudioComponentIfAudioFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["audio"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfAudioSourceFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["audio"]["source"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderAudioTest,
       DoesNotCreateAudioComponentIfNoAudioHandleInRegistry) {
  quoll::AssetData<quoll::AudioAsset> data{};
  data.uuid = quoll::Uuid("hello");

  auto handle = assetRegistry.getAudios().addAsset(data);

  auto [node, entity] = createNode();
  node["audio"]["source"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
}

TEST_F(SceneLoaderAudioTest, CreatesAudioComponentWithFileDataIfValidField) {
  quoll::AssetData<quoll::AudioAsset> data{};
  data.uuid = quoll::Uuid("hello");

  auto handle = assetRegistry.getAudios().addAsset(data);

  auto [node, entity] = createNode();
  node["audio"]["source"] = data.uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::AudioSource>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::AudioSource>(entity).source, handle);
}

using SceneLoaderScriptTest = SceneLoaderTest;

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfScriptFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Script>(entity));
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfScriptFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["script"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::Script>(entity));
  }
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateScriptComponentIfNoScriptHandleInRegistry) {
  quoll::AssetData<quoll::LuaScriptAsset> data{};
  data.uuid = quoll::Uuid("hello");

  auto handle = assetRegistry.getLuaScripts().addAsset(data);

  auto [node, entity] = createNode();
  node["script"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Script>(entity));
}

TEST_F(SceneLoaderScriptTest,
       CreatesScriptComponentWithFileDataIfStringFieldWithValidPath) {
  quoll::AssetData<quoll::LuaScriptAsset> data{};
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getLuaScripts().addAsset(data);

  auto [node, entity] = createNode();
  node["script"] = data.uuid;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Script>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Script>(entity).handle, handle);
}

TEST_F(SceneLoaderScriptTest,
       CreatesScriptComponentWithFileAndVariablesIfMapWithValidPath) {
  quoll::AssetData<quoll::LuaScriptAsset> data{};
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getLuaScripts().addAsset(data);

  quoll::AssetData<quoll::PrefabAsset> prefabData{};
  prefabData.uuid = quoll::Uuid("my-prefab");
  auto prefabHandle = assetRegistry.getPrefabs().addAsset(prefabData);

  auto [node, entity] = createNode();
  node["script"]["asset"] = data.uuid;
  node["script"]["variables"]["test_str"]["type"] = "string";
  node["script"]["variables"]["test_str"]["value"] = "Test string";
  node["script"]["variables"]["test_valid_prefab"]["type"] = "prefab";
  node["script"]["variables"]["test_valid_prefab"]["value"] = prefabData.uuid;
  node["script"]["variables"]["test_invalid_prefab"]["type"] = "prefab";
  node["script"]["variables"]["test_invalid_prefab"]["value"] =
      "unknown-prefab-file.prefab";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Script>(entity));
  const auto &script = entityDatabase.get<quoll::Script>(entity);

  EXPECT_EQ(script.handle, handle);

  // Invalid prefab is ignored
  EXPECT_FALSE(script.variables.contains("test_invalid_prefab"));
  EXPECT_EQ(script.variables.at("test_str").get<quoll::String>(),
            "Test string");
  EXPECT_EQ(
      script.variables.at("test_valid_prefab").get<quoll::PrefabAssetHandle>(),
      prefabHandle);
}

using SceneLoaderTextTest = SceneLoaderTest;

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<quoll::Text>(entity));
}

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["text"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderTextTest, DoesNotCreateTextComponentIfTextFontIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["text"]["font"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::Text>(entity));
  }
}

TEST_F(SceneLoaderScriptTest,
       DoesNotCreateTextComponentIfNoFontHandleInRegistry) {
  quoll::AssetData<quoll::FontAsset> data{};
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getFonts().addAsset(data);

  auto [node, entity] = createNode();
  node["text"]["font"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Text>(entity));
}

TEST_F(SceneLoaderScriptTest,
       TriesToFillTextComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  quoll::AssetData<quoll::FontAsset> data{};
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getFonts().addAsset(data);

  quoll::Text defaults{};

  auto validContent = "Hello world";
  auto validLineHeight = 20.0f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["text"]["lineHeight"] = invalidNode;
    node["text"]["content"] = validContent;
    node["text"]["font"] = data.uuid;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    ASSERT_TRUE(entityDatabase.has<quoll::Text>(entity));
    const auto &text = entityDatabase.get<quoll::Text>(entity);

    EXPECT_EQ(text.text, validContent);
    EXPECT_EQ(text.lineHeight, defaults.lineHeight);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["text"]["lineHeight"] = validLineHeight;
    node["text"]["content"] = invalidNode;
    node["text"]["font"] = data.uuid;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    ASSERT_TRUE(entityDatabase.has<quoll::Text>(entity));
    const auto &text = entityDatabase.get<quoll::Text>(entity);

    EXPECT_EQ(text.text, defaults.text);
    EXPECT_EQ(text.lineHeight, validLineHeight);
  }
}

TEST_F(SceneLoaderTextTest, CreatesTextComponentWithFileDataIfValidField) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  quoll::AssetData<quoll::FontAsset> data{};
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getFonts().addAsset(data);

  quoll::Text defaults{};

  auto validContent = "Hello world";
  auto validLineHeight = 20.0f;

  auto [node, entity] = createNode();
  node["text"]["lineHeight"] = validLineHeight;
  node["text"]["content"] = validContent;
  node["text"]["font"] = data.uuid;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Text>(entity));
  const auto &text = entityDatabase.get<quoll::Text>(entity);

  EXPECT_EQ(text.text, validContent);
  EXPECT_EQ(text.lineHeight, validLineHeight);
  EXPECT_EQ(text.font, handle);
}

using SceneLoaderRigidBodyTest = SceneLoaderTest;

TEST_F(SceneLoaderRigidBodyTest,
       DoesNotCreateRigidBodyComponentIfRigidBodyFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<quoll::RigidBody>(entity));
}

TEST_F(SceneLoaderRigidBodyTest,
       DoesNotCreateRigidBodyComponentIfRigidBodyFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["rigidBody"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderRigidBodyTest,
       TriesToFillRigidBodyComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  quoll::RigidBody defaultComponent{};
  auto defaults = defaultComponent.dynamicDesc;

  auto validMass = 2.5f;
  auto validInertia = glm::vec3(2.5f);
  auto validGravity = true;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["rigidBody"]["mass"] = invalidNode;
    node["rigidBody"]["inertia"] = validInertia;
    node["rigidBody"]["gravity"] = validGravity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
    const auto &rigidBody =
        entityDatabase.get<quoll::RigidBody>(entity).dynamicDesc;

    EXPECT_EQ(rigidBody.mass, defaults.mass);
    EXPECT_EQ(rigidBody.inertia, validInertia);
    EXPECT_EQ(rigidBody.applyGravity, validGravity);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["rigidBody"]["mass"] = validMass;
    node["rigidBody"]["inertia"] = invalidNode;
    node["rigidBody"]["gravity"] = validGravity;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
    const auto &rigidBody =
        entityDatabase.get<quoll::RigidBody>(entity).dynamicDesc;

    EXPECT_EQ(rigidBody.mass, validMass);
    EXPECT_EQ(rigidBody.inertia, defaults.inertia);
    EXPECT_EQ(rigidBody.applyGravity, validGravity);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["rigidBody"]["mass"] = validMass;
    node["rigidBody"]["inertia"] = validInertia;
    node["rigidBody"]["gravity"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
    const auto &rigidBody =
        entityDatabase.get<quoll::RigidBody>(entity).dynamicDesc;

    EXPECT_EQ(rigidBody.mass, validMass);
    EXPECT_EQ(rigidBody.inertia, validInertia);
    EXPECT_EQ(rigidBody.applyGravity, defaults.applyGravity);
  }
}

TEST_F(SceneLoaderRigidBodyTest,
       CreatesRigidBodyComponentWithFileDataIfValidField) {
  auto validMass = 2.5f;
  auto validInertia = glm::vec3(2.5f);
  auto validGravity = true;

  auto [node, entity] = createNode();
  node["rigidBody"]["mass"] = validMass;
  node["rigidBody"]["inertia"] = validInertia;
  node["rigidBody"]["applyGravity"] = validGravity;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::RigidBody>(entity));
  const auto &rigidBody =
      entityDatabase.get<quoll::RigidBody>(entity).dynamicDesc;

  EXPECT_EQ(rigidBody.mass, validMass);
  EXPECT_EQ(rigidBody.inertia, validInertia);
  EXPECT_EQ(rigidBody.applyGravity, validGravity);
}

using SceneLoaderCollidableTest = SceneLoaderTest;

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<quoll::Collidable>(entity));
}

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableFieldIsNotMap) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::AudioSource>(entity));
  }
}

TEST_F(SceneLoaderCollidableTest,
       DoesNotCreateCollidableComponentIfCollidableShapeIsUnknown) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  node["collidable"]["shape"] = "unknown";

  EXPECT_FALSE(entityDatabase.has<quoll::Collidable>(entity));
}

TEST_F(SceneLoaderCollidableTest,
       SetsCenterToZeroIfCollidableCenterFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "box";
    node["collidable"]["center"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &center =
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.center;

    EXPECT_EQ(center, glm::vec3(0.0f));
  }
}

TEST_F(SceneLoaderCollidableTest, SetsCenterToProvidedCenterFieldIfValid) {
  auto input = glm::vec3{2.5f, 3.5f, 4.5f};

  auto [node, entity] = createNode();
  node["collidable"]["shape"] = "box";
  node["collidable"]["center"] = input;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &center =
      entityDatabase.get<quoll::Collidable>(entity).geometryDesc.center;

  EXPECT_EQ(center, input);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableBoxComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = quoll::PhysicsGeometryBox{};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "box";
    node["collidable"]["halfExtents"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &collidable = std::get<quoll::PhysicsGeometryBox>(
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.halfExtents, defaults.halfExtents);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesBoxCollidableWithFileDataIfValidField) {
  auto validHalfExtents = glm::vec3(2.5f);

  auto [node, entity] = createNode();
  node["collidable"]["shape"] = "box";
  node["collidable"]["halfExtents"] = validHalfExtents;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &collidable = std::get<quoll::PhysicsGeometryBox>(
      entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

  EXPECT_EQ(collidable.halfExtents, validHalfExtents);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableSphereComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = quoll::PhysicsGeometrySphere{};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "sphere";
    node["collidable"]["radius"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &collidable = std::get<quoll::PhysicsGeometrySphere>(
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.radius, defaults.radius);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesSphereCollidableWithFileDataIfValidField) {
  auto validRadius = 2.5f;

  auto [node, entity] = createNode();
  node["collidable"]["shape"] = "sphere";
  node["collidable"]["radius"] = validRadius;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &collidable = std::get<quoll::PhysicsGeometrySphere>(
      entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

  EXPECT_EQ(collidable.radius, validRadius);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableCapsuleComponentIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = quoll::PhysicsGeometryCapsule{};

  auto validHalfHeight = 3.5f;
  auto validRadius = 2.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "capsule";
    node["collidable"]["radius"] = invalidNode;
    node["collidable"]["halfHeight"] = validHalfHeight;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &collidable = std::get<quoll::PhysicsGeometryCapsule>(
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.radius, defaults.radius);
    EXPECT_EQ(collidable.halfHeight, validHalfHeight);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["collidable"]["shape"] = "capsule";
    node["collidable"]["radius"] = validRadius;
    node["collidable"]["halfHeight"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &collidable = std::get<quoll::PhysicsGeometryCapsule>(
        entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

    EXPECT_EQ(collidable.radius, validRadius);
    EXPECT_EQ(collidable.halfHeight, defaults.halfHeight);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesCapsuleCollidableWithFileDataIfValidField) {
  auto validHalfHeight = 3.5f;
  auto validRadius = 2.5f;

  auto [node, entity] = createNode();
  node["collidable"]["shape"] = "capsule";
  node["collidable"]["radius"] = validRadius;
  node["collidable"]["halfHeight"] = validHalfHeight;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &collidable = std::get<quoll::PhysicsGeometryCapsule>(
      entityDatabase.get<quoll::Collidable>(entity).geometryDesc.params);

  EXPECT_EQ(collidable.radius, validRadius);
  EXPECT_EQ(collidable.halfHeight, validHalfHeight);
}

TEST_F(SceneLoaderCollidableTest,
       TriesToFillCollidableComponentMaterialsIfFieldPropertiesAreInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  auto defaults = quoll::PhysicsMaterialDesc{};

  auto validDynamicFriction = 3.5f;
  auto validRestitution = 2.5f;
  auto validStaticFriction = 1.5f;

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["dynamicFriction"] = invalidNode;
    node["collidable"]["restitution"] = validRestitution;
    node["collidable"]["staticFriction"] = validStaticFriction;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &material =
        entityDatabase.get<quoll::Collidable>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, defaults.dynamicFriction);
    EXPECT_EQ(material.restitution, validRestitution);
    EXPECT_EQ(material.staticFriction, validStaticFriction);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "sphere";
    node["collidable"]["dynamicFriction"] = validDynamicFriction;
    node["collidable"]["restitution"] = invalidNode;
    node["collidable"]["staticFriction"] = validStaticFriction;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &material =
        entityDatabase.get<quoll::Collidable>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
    EXPECT_EQ(material.restitution, defaults.restitution);
    EXPECT_EQ(material.staticFriction, validStaticFriction);
  }

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "capsule";
    node["collidable"]["dynamicFriction"] = validDynamicFriction;
    node["collidable"]["restitution"] = validRestitution;
    node["collidable"]["staticFriction"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    const auto &material =
        entityDatabase.get<quoll::Collidable>(entity).materialDesc;

    EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
    EXPECT_EQ(material.restitution, validRestitution);
    EXPECT_EQ(material.staticFriction, defaults.staticFriction);
  }
}

TEST_F(SceneLoaderCollidableTest,
       CreatesCollidableMaterialsWithFileDataIfValidField) {
  auto validDynamicFriction = 3.5f;
  auto validRestitution = 2.5f;
  auto validStaticFriction = 1.5f;

  auto [node, entity] = createNode();
  // Shape does not matter here
  node["collidable"]["shape"] = "plane";
  node["collidable"]["dynamicFriction"] = validDynamicFriction;
  node["collidable"]["restitution"] = validRestitution;
  node["collidable"]["staticFriction"] = validStaticFriction;

  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
  const auto &material =
      entityDatabase.get<quoll::Collidable>(entity).materialDesc;

  EXPECT_EQ(material.dynamicFriction, validDynamicFriction);
  EXPECT_EQ(material.restitution, validRestitution);
  EXPECT_EQ(material.staticFriction, validStaticFriction);
}

TEST_F(SceneLoaderCollidableTest, SetsCollidableModesToTrueIfInvalidField) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = invalidNode;
    node["collidable"]["useInQueries"] = invalidNode;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }
}

TEST_F(SceneLoaderCollidableTest, SetsCollidableModesToDataInFileIfValid) {
  {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = false;
    node["collidable"]["useInQueries"] = false;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_FALSE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_FALSE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }

  {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = true;
    node["collidable"]["useInQueries"] = false;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_FALSE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }

  {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = false;
    node["collidable"]["useInQueries"] = true;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_FALSE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }

  {
    auto [node, entity] = createNode();
    // Shape does not matter here
    node["collidable"]["shape"] = "box";
    node["collidable"]["useInSimulation"] = true;
    node["collidable"]["useInQueries"] = true;

    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::Collidable>(entity));
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInSimulation);
    EXPECT_TRUE(entityDatabase.get<quoll::Collidable>(entity).useInQueries);
  }
}

using SceneLoaderParentTest = SceneLoaderTest;

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentFieldDoesNotExist) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Parent>(entity));
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["transform"]["parent"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::Parent>(entity));
  }
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentDoesNotExist) {
  static constexpr uint64_t NonExistentId = 255;
  auto [parentNode, parentEntity] = createNode();

  auto [node, entity] = createNode();
  node["transform"]["parent"] = NonExistentId;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Parent>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::Children>(parentEntity));
}

TEST_F(SceneLoaderParentTest,
       DoesNotCreateParentComponentIfParentIsNotCreatedWithSceneLoader) {
  static constexpr uint64_t ParentId = 255;

  auto parentEntity = entityDatabase.create();
  entityDatabase.set<quoll::Id>(parentEntity, {ParentId});

  auto [node, entity] = createNode();
  node["transform"]["parent"] = ParentId;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::Parent>(entity));
  EXPECT_FALSE(entityDatabase.has<quoll::Children>(parentEntity));
}

TEST_F(SceneLoaderParentTest, CreatesParentComponentIfParentEntityExists) {
  auto [parentNode, parentEntity] = createNode();

  auto [node, entity] = createNode();
  node["transform"]["parent"] = parentNode["id"];
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Parent>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Parent>(entity).parent, parentEntity);
  ASSERT_TRUE(entityDatabase.has<quoll::Children>(parentEntity));
  EXPECT_EQ(entityDatabase.get<quoll::Children>(parentEntity).children.at(0),
            entity);
}

TEST_F(SceneLoaderParentTest,
       AddsChildToParentComponentIfChildrenComponentAlreadyExists) {
  auto [parentNode, parentEntity] = createNode();
  entityDatabase.set<quoll::Children>(parentEntity, {{quoll::Entity::Null}});

  auto [node, entity] = createNode();
  node["transform"]["parent"] = parentNode["id"];
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::Parent>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::Parent>(entity).parent, parentEntity);
  ASSERT_TRUE(entityDatabase.has<quoll::Children>(parentEntity));
  EXPECT_EQ(entityDatabase.get<quoll::Children>(parentEntity).children.at(1),
            entity);
}

using SceneLoaderActiveCameraTest = SceneLoaderTest;

TEST_F(SceneLoaderActiveCameraTest, ReturnsErrorIfStartingCameraIsNotAnId) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  for (auto node : invalidNodes) {
    auto res = sceneLoader.loadStartingCamera(node, entityIdCache);
    EXPECT_TRUE(res.hasError());
  }
}

TEST_F(SceneLoaderActiveCameraTest, ReturnsErrorIfStartingCameraDoesNotExist) {
  YAML::Node node(23232);

  auto res = sceneLoader.loadStartingCamera(node, entityIdCache);
  EXPECT_TRUE(res.hasError());
}

TEST_F(SceneLoaderActiveCameraTest,
       ReturnsErrorIfStartingCameraDoesNotHaveCameraComponent) {
  auto idNode = createNode(true).first;

  auto res = sceneLoader.loadStartingCamera(idNode["id"], entityIdCache);
  EXPECT_TRUE(res.hasError());
}

TEST_F(SceneLoaderActiveCameraTest,
       ReturnsEntityIfStartingEntityExistsAndHasACamera) {
  auto startingCameraNode = createNode(true);
  entityDatabase.set<quoll::PerspectiveLens>(startingCameraNode.second, {});

  auto camera1 = createNode(true).second;
  entityDatabase.set<quoll::PerspectiveLens>(camera1, {});

  auto camera2 = createNode(true).second;
  entityDatabase.set<quoll::PerspectiveLens>(camera2, {});

  auto res = sceneLoader.loadStartingCamera(startingCameraNode.first["id"],
                                            entityIdCache);
  EXPECT_TRUE(res.hasData());
  EXPECT_EQ(res.getData(), startingCameraNode.second);
}

using SceneLoaderSkyboxTest = SceneLoaderTest;

TEST_F(SceneLoaderSkyboxTest, DoesNotAddSkyboxIfNoSkyboxField) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
}

TEST_F(SceneLoaderSkyboxTest, DoesNotAddSkyboxComponentIfSkyboxFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skybox"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  }
}

TEST_F(SceneLoaderSkyboxTest,
       DoesNotAddSkyboxComponentIfSkyboxTypeIsNotColorOrTexture) {
  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       YAML::Node("randomType")};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skybox"]["type"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  }
}

TEST_F(SceneLoaderSkyboxTest,
       DoesNotAddSkyboxComponentIfSkyboxTypeIsTextureButTextureIsNotDefined) {
  auto [node, entity] = createNode();
  node["skybox"]["type"] = "texture";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
}

TEST_F(SceneLoaderSkyboxTest,
       DoesNotAddSkyboxComponentIfSkyboxTypeIsTextureButTextureIsInvalid) {
  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       YAML::Node("randomUuid")};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skybox"]["type"] = "texture";
    node["skybox"]["texture"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  }
}

TEST_F(SceneLoaderSkyboxTest,
       AddsTextureSkyboxIfTypeIsTextureAndTextureExists) {
  quoll::AssetData<quoll::EnvironmentAsset> data{};
  data.uuid = quoll::Uuid("test-uuid.uuid");

  auto handle = assetRegistry.getEnvironments().addAsset(data);

  auto [node, entity] = createNode();
  node["skybox"]["type"] = "texture";
  node["skybox"]["texture"] = "test-uuid.uuid";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  ASSERT_TRUE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  const auto &component = entityDatabase.get<quoll::EnvironmentSkybox>(entity);
  EXPECT_EQ(component.type, quoll::EnvironmentSkyboxType::Texture);
  EXPECT_EQ(component.texture, handle);
}

TEST_F(SceneLoaderSkyboxTest,
       AddsColorSkyboxWithBlackColorIfTypeIsColorButColorIsNotDefined) {
  auto [node, entity] = createNode();
  node["skybox"]["type"] = "color";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  ASSERT_TRUE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));

  const auto &component = entityDatabase.get<quoll::EnvironmentSkybox>(entity);
  EXPECT_EQ(component.type, quoll::EnvironmentSkyboxType::Color);
  EXPECT_EQ(component.color, glm::vec4(0.0f, 0.0f, 0.0f, 1.0f));
}

TEST_F(SceneLoaderSkyboxTest,
       AddsColorSkyboxWithBlackColorIfTypeIsColorButColorIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["skybox"]["type"] = "color";
    node["skybox"]["color"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    ASSERT_TRUE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));

    const auto &component =
        entityDatabase.get<quoll::EnvironmentSkybox>(entity);
    EXPECT_EQ(component.type, quoll::EnvironmentSkyboxType::Color);
    EXPECT_EQ(component.color, glm::vec4(0.0f, 0.0f, 0.0f, 1.0f));
  }
}

TEST_F(SceneLoaderSkyboxTest, AddsColorSkyboxIfTypeIsColorAndColorIsDefined) {
  quoll::AssetData<quoll::EnvironmentAsset> data{};
  data.uuid = quoll::Uuid("test-uuid.uuid");

  auto handle = assetRegistry.getEnvironments().addAsset(data);

  auto [node, entity] = createNode();
  node["skybox"]["type"] = "color";
  node["skybox"]["color"] = glm::vec4(0.4f, 0.2f, 0.5f, 0.2f);
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  ASSERT_TRUE(entityDatabase.has<quoll::EnvironmentSkybox>(entity));
  const auto &component = entityDatabase.get<quoll::EnvironmentSkybox>(entity);
  EXPECT_EQ(component.type, quoll::EnvironmentSkyboxType::Color);
  EXPECT_EQ(component.color, glm::vec4(0.4f, 0.2f, 0.5f, 0.2f));
}

using SceneLoaderEnvironmentLightingTest = SceneLoaderTest;

TEST_F(SceneLoaderEnvironmentLightingTest,
       DoesNotAddEnvironmentLightingIfNoEnvironmentLightingField) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(
      entityDatabase.has<quoll::EnvironmentLightingSkyboxSource>(entity));
}

TEST_F(SceneLoaderEnvironmentLightingTest,
       DoesNotAddEnvironmentLightingIfFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map), YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["environmentLighting"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(
        entityDatabase.has<quoll::EnvironmentLightingSkyboxSource>(entity));
  }
}

TEST_F(SceneLoaderEnvironmentLightingTest,
       DoesNotAddEnvironmentLightingIfSourceIsInvalid) {
  std::vector<YAML::Node> invalidNodes{YAML::Node(YAML::NodeType::Undefined),
                                       YAML::Node(YAML::NodeType::Null),
                                       YAML::Node(YAML::NodeType::Map),
                                       YAML::Node(YAML::NodeType::Sequence),
                                       YAML::Node(YAML::NodeType::Scalar),
                                       YAML::Node("randomSource")};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["environmentLighting"]["source"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(
        entityDatabase.has<quoll::EnvironmentLightingSkyboxSource>(entity));
  }
}

TEST_F(SceneLoaderEnvironmentLightingTest,
       AddsSkyboxEnvironmentLightingSourceIfSourceIsSkybox) {
  auto [node, entity] = createNode();
  node["environmentLighting"]["source"] = "skybox";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();
  EXPECT_TRUE(
      entityDatabase.has<quoll::EnvironmentLightingSkyboxSource>(entity));
}

using SceneLoaderActiveEnvironmentTest = SceneLoaderTest;

TEST_F(SceneLoaderActiveEnvironmentTest, ReturnsErrorIfEnvironmentIsNotId) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined),
      YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Sequence),
      YAML::Node(YAML::NodeType::Scalar),
  };

  for (auto node : invalidNodes) {
    auto res = sceneLoader.loadEnvironment(node, entityIdCache);
    EXPECT_TRUE(res.hasError());
  }
}

TEST_F(SceneLoaderActiveEnvironmentTest,
       ReturnsErrorIfEnvironmentEntityDoesNotExist) {
  YAML::Node node(23232);

  auto res = sceneLoader.loadEnvironment(node, entityIdCache);
  EXPECT_TRUE(res.hasError());
}

TEST_F(SceneLoaderActiveCameraTest, ReturnsEntityIfEnvironmentEntityExists) {
  auto environmentNode = createNode(true);

  auto res =
      sceneLoader.loadEnvironment(environmentNode.first["id"], entityIdCache);
  EXPECT_TRUE(res.hasData());
  EXPECT_EQ(res.getData(), environmentNode.second);
}

using SceneLoaderInputMapTest = SceneLoaderTest;

TEST_F(SceneLoaderInputMapTest,
       DoesNotCreateInputMapComponentIfInputMapFieldIsNotDefined) {
  auto [node, entity] = createNode();
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
}

TEST_F(SceneLoaderInputMapTest,
       DoesNotCreateInputMapComponentIfInputMapFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["inputMap"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
  }
}

TEST_F(SceneLoaderInputMapTest,
       DoesNotCreateInputMapComponentIfInputMapAssetFieldIsInvalid) {
  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Scalar)};

  for (const auto &invalidNode : invalidNodes) {
    auto [node, entity] = createNode();
    node["inputMap"]["asset"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();
    EXPECT_FALSE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
  }
}

TEST_F(SceneLoaderInputMapTest,
       DoesNotCreateInputMapComponentIfNoInputMapHandleInRegistry) {
  quoll::AssetData<quoll::InputMapAsset> data{};
  data.uuid = quoll::Uuid("hello");
  data.type = quoll::AssetType::InputMap;
  auto handle = assetRegistry.getInputMaps().addAsset(data);

  auto [node, entity] = createNode();
  node["inputMap"]["asset"] = "bye";
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  EXPECT_FALSE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
}

TEST_F(SceneLoaderInputMapTest, CreatesInputMapComponentIfInputMapAssetExists) {
  quoll::AssetData<quoll::InputMapAsset> data{};
  data.type = quoll::AssetType::InputMap;
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getInputMaps().addAsset(data);

  auto [node, entity] = createNode();
  node["inputMap"]["asset"] = data.uuid;
  node["inputMap"]["defaultScheme"] = 1;
  sceneLoader.loadComponents(node, entity, entityIdCache).getData();

  ASSERT_TRUE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
  EXPECT_EQ(entityDatabase.get<quoll::InputMapAssetRef>(entity).handle, handle);
  EXPECT_EQ(entityDatabase.get<quoll::InputMapAssetRef>(entity).defaultScheme,
            1);
}

TEST_F(SceneLoaderInputMapTest, SetsInputMapDefaultSchemeToZeroIfInvalidField) {
  quoll::AssetData<quoll::InputMapAsset> data{};
  data.type = quoll::AssetType::InputMap;
  data.uuid = quoll::Uuid("hello");
  auto handle = assetRegistry.getInputMaps().addAsset(data);

  std::vector<YAML::Node> invalidNodes{
      YAML::Node(YAML::NodeType::Undefined), YAML::Node(YAML::NodeType::Null),
      YAML::Node(YAML::NodeType::Sequence), YAML::Node(YAML::NodeType::Map),
      YAML::Node(YAML::NodeType::Scalar)};

  for (auto invalidNode : invalidNodes) {

    auto [node, entity] = createNode();
    node["inputMap"]["asset"] = data.uuid;
    node["inputMap"]["defaultScheme"] = invalidNode;
    sceneLoader.loadComponents(node, entity, entityIdCache).getData();

    ASSERT_TRUE(entityDatabase.has<quoll::InputMapAssetRef>(entity));
    EXPECT_EQ(entityDatabase.get<quoll::InputMapAssetRef>(entity).defaultScheme,
              0);
  }
}
